\documentclass[times, % the default MS fonts which the commission likes
			   specification,annotation, % generate aux pages in the primary language
			   titlepage-extra-ru,specification-extra-ru,annotation-extra-ru, % generate aux pages + title in Russian
			   languages={russian,english} % sets English as the primary language and also loads Russian
			  ]{itmo-student-thesis}

%% Опции пакета:
%% - specification - если есть, генерируется задание, иначе не генерируется
%% - annotation - если есть, генерируется аннотация, иначе не генерируется
%% - times - делает все шрифтом Times New Roman, собирается с помощью xelatex
%% - languages={...} - устанавливает перечень используемых языков. По умолчанию это {english,russian}.
%%                     Последний из языков определяет текст основного документа.

%% Один из пакетов, позволяющий делать таблицы на всю ширину текста.
\usepackage{tabularx}

%% Данные пакеты необязательны к использованию в бакалаврских/магистерских
%% Они нужны для иллюстративных целей
%% Начало
\usepackage{svg}
\usepackage{tikz}
\usepackage{subfig}
\usepackage{xcolor}
%\usepackage[hidelinks]{hyperref}
\usetikzlibrary{arrows}
\usepackage{filecontents}
\begin{filecontents}{bachelor-thesis.bib}
@online{ doerr-doerr-lambda-lambda-self-adjustment-arxiv,
	year        = {2015},
	title       = {Optimal Parameter Choices Through Self-Adjustment: Applying the 1/5-th Rule in
				   Discrete Settings},
	author      = {Benjamin Doerr and Carola Doerr},
	url         = {http://arxiv.org/abs/1504.03212},
	year        = {2015},
	langid      = {english}
}

@inproceedings{ example-english,
	year        = {2015},
	booktitle   = {Proceedings of IEEE Congress on Evolutionary Computation},
	author      = {Maxim Buzdalov and Anatoly Shalyto},
	title       = {Hard Test Generation for Augmenting Path Maximum Flow
				   Algorithms using Genetic Algorithms: Revisited},
	pages       = {2121-2128},
	langid      = {english}
}

@article{ example-russian,
	author      = {Максим Викторович Буздалов},
	title       = {Генерация тестов для олимпиадных задач по программированию
				   с использованием генетических алгоритмов},
	journal     = {Научно-технический вестник {СПбГУ} {ИТМО}},
	number      = {2(72)},
	year        = {2011},
	pages       = {72-77},
	langid      = {russian}
}

@article{ unrestricted-jump-evco,
	author      = {Maxim Buzdalov and Benjamin Doerr and Mikhail Kever},
	title       = {The Unrestricted Black-Box Complexity of Jump Functions},
	journal     = {Evolutionary Computation},
	year        = {2016},
	note        = {Accepted for publication},
	langid      = {english}
}

@book{ bellman,
	author      = {R. E. Bellman},
	title       = {Dynamic Programming},
	address     = {Princeton, NJ},
	publisher   = {Princeton University Press},
	numpages    = {342},
	pagetotal   = {342},
	year        = {1957},
	langid      = {english}
}
\end{filecontents}
%% Конец

%% Указываем файл с библиографией.
\addbibresource{bachelor-thesis.bib}

\begin{document}

\newcommand{\TODO}{{ \color{red} TODO }}

\studygroup{M34361}
\publishyear{2019}
\startdate{01}{December}{2022}
\finishdate{31}{May}{2023}
\defencedate{15}{June}{2023}


%%% ENGLISH

\title{Support of Function Invocation and Objects Passing between Statically and Dynamically Typed Languages on the Ark Platform}
\author{Prokopenko K}{Prokopenko K.D.}
\supervisor{Filchenkov Andrey Alexandrovich}{Filchenkov A.A.}{PhD}{TODO}

\addconsultant{Solomennikov D.I.}{no degree}

\secretary{Pavlova O.N.}

%% Objectives/Specification

%%% Requirements and premise
\technicalspec{It is requried to develop a \LaTeX\ classfile, which enables convenient typesetting of Bachelor's and Master's theses
at the former Computer Technologies department in ITMO University. This classfile shall produce the title page, the page with objectives and summary,
as well as the main body of the text; the former three shall also be generated in Russian according to the official guildelines.
The main body shall closely follow the GOST~7.0.11-2011 standard on dissertations, while the other parts shall closely follow the existing Word-based
templates.}

%%% Content of the thesis
\plannedcontents{The main body shall test the usage of the most frequent text elements, including enumerations, figures, tables, listings (including pseudocode).
The structure of the main body shall also serve as the unit test, e.g. one shall be able to validate the correctness of the classfile by just looking at it.
In particular, the main body shall contain at least two appendices (in order to validate that figures and tables have chapter-based numbering in appendices)
and at least ten enumeration items at the first level (to check whether illegal letters do not appear).}

%%% Исходные материалы и пособия
\plannedsources{\begin{enumerate}
	\item GOST~7.0.11-2011 <<Disseration and disseration synopsis>>;
	\item Lvovskiy M., Typesetting in \LaTeX;
	\item the previous pack of style files, which has been used some ten years ago.
\end{enumerate}}

%% Summary/Annotation

%%% Research objective
\researchaim{Development of a convenient \LaTeX\ classfile for bachelors and masters of the former Computer Technologies department.}

%%% Research tasks
\researchtargets{\begin{enumerate}
	\item closely mimicking the existing templates for a title page, specification/objectives, annotation/summary;
	\item closely following the GOST~7.0.11-2011 standard in the main body of the text;
	\item ensuring reasonable convenience, in particular, specifying multiple-occuring data once, counting sources by types where necessary, etc.
\end{enumerate}}

%%% Use of modern software suites
\addadvancedsoftware{The \texttt{tabularx} package for slighly more powerful tables}{\ref{sec:tables}, Appendices~\ref{sec:app:1}, \ref{sec:app:2}}
\addadvancedsoftware{The \texttt{biblatex} package and the \texttt{biber} program}{References}

%%% Short summary of results
\researchsummary{The previous, Russian-only classfile gained some noticeable use in years 2015--2018.
This probably means that it is reasonably well-done. The current bi-lingual version is slightly more cumbersome,
although it is source-compatible with the previous one, which is good.}

%%% Grants received while working
\researchfunding{I would like to thank the aunties at ITMO University who constantly make small changes to the original template,
including using some of the obscure Word features and making more new mistakes, as my life would otherwise be not so filled with the shear beauty of being.
The original ideas were developed while I prepared my PhD thesis in \LaTeX, as well as tons of scientific reports
for various stages of the ``5-in-100'' grant of the Ministry of Science and Higher Education (project 08-08).}

%%% Publications on the topic of the thesis: do you have any?
\researchpublications{No, I have not (thankfully!) published anything about this thesis.
\begin{refsection}
However, I am going to show here how you can refer to your own publications:
\nocite{example-english, example-russian}
\printannobibliography
\end{refsection}
}

%%% RUSSIAN

\selectlanguage{russian}

\title{Поддержка вызовов функций и передачи объектов между языками со статическими и динамическими типизациями на платформе Ark}
\author{Прокопенко Кирилл Дмитриевич}{Прокопенко К.Д.}
\supervisor{Фильченков Андрей Александрович}{Фильченков А.А.}{проф., д.т.н.}{кандидат физико-математических наук}
\addconsultant{Соломенников Д.И.}{без степени, без звания}
\secretary{Павлова О.Н.}

%% Задание
%%% Техническое задание и исходные данные к работе
\technicalspec{Требуется разработать стилевой файл для системы \LaTeX, позволяющий оформлять бакалаврские работы и магистерские диссертации
на кафедре компьютерных технологий Университета ИТМО. Стилевой файл должен генерировать титульную страницу пояснительной записки,
задание, аннотацию и содержательную часть пояснительной записк. Первые три документа должны максимально близко соответствовать шаблонам документов,
принятым в настоящий момент на кафедре, в то время как содержательная часть должна максимально близко соответствовать ГОСТ~7.0.11-2011
на диссертацию.}

%%% Содержание выпускной квалификационной работы (перечень подлежащих разработке вопросов)
\plannedcontents{Пояснительная записка должна демонстрировать использование наиболее типичных конструкций, возникающих при составлении
пояснительной записки (перечисления, рисунки, таблицы, листинги, псевдокод), при этом должна быть составлена так, что демонстрируется
корректность работы стилевого файла. В частности, записка должна содержать не менее двух приложений (для демонстрации нумерации рисунков и таблиц
по приложениям согласно ГОСТ) и не менее десяти элементов нумерованного перечисления первого уровня вложенности (для демонстрации корректности
используемого при нумерации набора русских букв).}

%%% Исходные материалы и пособия
\plannedsources{\begin{enumerate}
	\item ГОСТ~7.0.11-2011 <<Диссертация и автореферат диссертации>>;
	\item С.М. Львовский. Набор и верстка в системе \LaTeX;
	\item предыдущий комплект стилевых файлов, использовавшийся на кафедре компьютерных технологий.
\end{enumerate}}

%%% Цель исследования
\researchaim{Разработка удобного стилевого файла \LaTeX
			 для бакалавров и магистров кафедры компьютерных технологий.}

%%% Задачи, решаемые в ВКР
\researchtargets{\begin{enumerate}
	\item обеспечение соответствия титульной страницы, задания и аннотации шаблонам, принятым в настоящее время на кафедре;
	\item обеспечение соответствия содержательной части пояснительной записки требованиям ГОСТ~7.0.11-2011 <<Диссертация и автореферат диссертации>>;
	\item обеспечение относительного удобства в использовании~--- указание данных об авторе и научном руководителе один раз и в одном месте, автоматический подсчет числа тех или иных источников.
\end{enumerate}}

%%% Использование современных пакетов компьютерных программ и технологий
\addadvancedsoftware{Пакет \texttt{tabularx} для чуть более продвинутых таблиц}{\ref{sec:tables}, Приложения~\ref{sec:app:1}, \ref{sec:app:2}}
\addadvancedsoftware{Пакет \texttt{biblatex} и программное средство \texttt{biber}}{Список использованных источников}

%%% Краткая характеристика полученных результатов
\researchsummary{Получился, надо сказать, практически неплохой стилевик. В 2015--2018 годах
его уже использовали некоторые бакалавры и магистры. Надеюсь на продолжение.}

%%% Гранты, полученные при выполнении работы
\researchfunding{Автор разрабатывал этот стилевик исключительно за свой счет и на
добровольных началах. Однако значительная его часть была бы невозможна, если бы
автор не написал в свое время кандидатскую диссертацию в \LaTeX,
а также не отвечал за формирование кучи научно-технических отчетов по гранту,
известному как <<5-в-100>>, что происходило при государственной финансовой поддержке
ведущих университетов Российской Федерации (субсидия 074-U01).}

%%% Наличие публикаций и выступлений на конференциях по теме выпускной работы
\researchpublications{По теме этой работы я (к счастью!) ничего не публиковал.
\begin{refsection}
Однако покажу, как можно ссылаться на свои публикации из списка литературы:
\nocite{example-english, example-russian}
\printannobibliography
\end{refsection}
}

\selectlanguage{english}

%% Эта команда генерирует титульный лист и аннотацию.
\maketitle{Бакалавр}

%% Оглавление
\tableofcontents

%% Макрос для введения. Совместим со старым стилевиком.
\startprefacepage

Language interoperability is important for several reasons:

\begin{enumerate}
\item Collaboration: When different teams or individuals work on a project, they may use different programming languages. Interoperability ensures that these different languages can work together seamlessly, allowing for more efficient collaboration and development.

\item Reusability: Interoperability allows developers to reuse code that has already been written in a different language. For instance, it can expose graphics library interface from statically typed language to dynamically, without requiring to write any code or generating bindings. It can be done in the opposite direction as well: rewriting underlying library in a faster language.

\item Flexibility: While most modern languages are ``general purpose'', it doesn't mean that they don't suit some tasks better than others. For instance, ecmascript-compliant languages are popular in sphere of creating user interfaces, not only because they were only alternative in browsers for a long time, but also because of simplifications that dynamic typing provides, which makes it easier for companies to hire developers in such languages. Ability to choose language suitable for a job provides greater flexibility in designing and implementing solutions.
\end{enumerate}

While programming languages interopability is not a solved problem, amount of projects that aim to ease languages communication points to presence of demand in this sphere.

%% Начало содержательной части.
\chapter{Overview}

\startrelatedwork
Пример ссылок в рамках обзора: \cite{example-english, example-russian, unrestricted-jump-evco, doerr-doerr-lambda-lambda-self-adjustment-arxiv}.

\section{Terminology}
\TODO

\section{Existing solutions}
\subsection{Native-native}
Interop in this area boils down to exposing common interfaces compatible with C language ABI. Notable solutions are entire languages: C++ and zig, which, basically, support including C header files (in case of C++ special mark \texttt{extern "C"} is required, while in zig it is possible to just \texttt{@cInclude} file, which will parse it with clang and automatically convert bindings to corresponding internal zig forward declarations)

\subsection{Managed-native}
\subsubsection{JNI}
To work around a moving garbage collector, all pointers to objects are stored in a dedicated array, where they are updated by GC, and native code can work with them only via indirect handles, which point to that array. Raw pointer can't be acquired, because native code doesn't insert ``safe points'' with any regularity, and to provide stability of JVM while thread is executing native code, it is considered to be in a safe point for whole time (which, for instance, allows garbage collector to run). As this implies checking GC status on each java-heap access, additional ``critical'' functions are brought into API, such as \texttt{GetPrimitiveArrayCritical}, which acquires raw pointer to array of primitives data, and blocks garbage collector from running until release of this pointer. Also, there is no API to access native data from Java, which makes all interop Java-centric and forces to make getters/setters in native api, calls to which are slower than to managed code.\\
As of other limitations, it requires generating a header file, which makes this tool slightly less convenient.
\subsubsection{Project panama}
Project that addresses limitations of JNI. It allows to call native functions with variadic arguments (note that in java they are packed into an array, while on native platforms they are passed in unsafe manner: via registers or on stack, without any control of their count, which can cause memory bugs), allows to access native heap in a more safe and easy way than \texttt{sun.misc.Unsafe}. Declaring natively layouted structures in java may be useful as well, because JVM is allowed to reorder fields as it wishes, which makes it impossible to explicitly pad them to avoid false sharing. Hence this project may be useful even for java-only projects.
\subsubsection{LuaJIT}
Introduces entire C language declarations parser to extend type system of lua with ``\texttt{cdata}'' type in addition to tables, numbers, etc. This approach allows to access C structures fields and call foreign functions with native performance, with an assumption that they don't modify lua state.
\subsubsection{CPPYY}
Exposes C++ code to python. This is possible with cling: C++ interpreter and JIT compiler, based on clang and LLVM. While it may be convenient to separate large parts of application into C++ library, this tool doesn't erase cost of calling a function in python. Simple micro-benchmark at appendix~\ref{apx:cppyy-bench} demonstrates that calling trivial C++ function may be even slower, because it also requires reboxing numbers at language boundary.
\subsubsection{Haskell FFI}
Allows to call functions from shared library with primitive types and pointers, which makes it unidirectional and limited. Access to C structures is done either via reads by offset with sizes, or via marshalling (which is a user-friendly wrapper for prior).

\subsection{Managed-Managed}
\subsubsection{JVM}
Most languages have relatively close type systems to Java, Groovy and Kotlin, and it is possible to compile them into single representation without significant performance degradation.\\
Other languages have compromises in their design (such as \texttt{null}'s in Scala) to be compatible with ``legacy'' systems, and allow slow migration to a more stable language.
\subsubsection{Nashorn}
Nashorn compiles ecmascript into java bytecode and raises exceptions to handle ``deoptimiations''. While it can outperform v8 on a simple benchmarks, it starts to lose when polymorphic functions come into the scene.

\subsubsection{GraalVM}
State of art VM which relies on a meta-circular optimization. While this approach yields fascinating results, it is not applicable to current work, as Ark platform has different runtimes and different instruction sets for each language. For instance, dynamic class representation has nothing in common with regular classes, which makes them incompatible. In different runtime parts of Ark platform even size of pointer is different, which arises problems with write barriers in garbage collection.

\section{Ark platform}
\TODO
registers and bytecodes

%% Так помечается конец обзора.
\finishrelatedwork

Вне обзора:~\cite{bellman}.

\section{Naive solution}
It would be possible to wrap every object from a statically typed language into a \texttt{Proxy} which would call native function to access fields and methods with a reflection library, however, such a solution is not only insufficient, because switching from managed to native context is costly and requires wrapping values into handles to prevent them from moving, but can also break equality reflexivity for proxies gain for the same object in a different way.

\chapter{SOLUTION}

Out of other solutions, LuaJIT will be the closest. To implement interopability on the dynamically typed site, new type tree is brought to represent ``foreign objects''. Then they are integrated into interpreter, which uses inline caches and collects profile info, which then is passed to a compiler. Who, on his side, brings new optimizations.

\section{Object representation on statically typed side}
As this work focuses on runtime part, while almost everything in a statically typed languages relies on a compiler and desugaring, this part will be covered superficially.\\
Type tree should be extended in a way, that previous root type should be rehanged to a new one, as shown in figure~\ref{fig:statically-typed-tree}.
\begin{figure}[!h]
	\caption{Modification of statically typed language hierarchy}\label{fig:statically-typed-tree}
	\centering
	\includesvg{build/res/dot/statically-typed-tree.dot}
\end{figure}
Casting types is implementation specific: in Ark, both class roots class defintions extend \texttt{BaseClass}, which holds flag if object is dynamic and other most generic info. This flag must be used for performing casts from \texttt{SomeObject}. As \texttt{ScriptObject} and \texttt{SomeObject} are unrelated, it would be a great solution to require upcast before downcast, as F\# does. Upcasting to new class root can be performed without any checks, as it is a synthetic type without actual runtime representation. For accessing dynamic flag new intrinsic (which can be inlined in the compiler as few loads and bit operations) must be implemented, because managed representations of classes are not compatible, and reflections library is unsuitable.\\
\texttt{ScriptObject} can have other fake successors for better type safety, or syntax sugar such as square brackets for property access.\\

\section{Object representation on dynamically typed side}
In dynamic languages, every value can be represented with a pointer to some \texttt{ObjectHeader}, however, such approach consumes insufficient amount of memory and requires allocation for each operation, as well as lengthens garbage collector pauses. As such, some implementations, such as LuaJIT use a technique called NaN boxing (which only alternative is pointer compression). According to IEEE754 standard double precision floating pointer number is represented as 1 bit for sign, 11 bits for exponent and 52 mantissa. NaN is represented with whole exponent set to 1, and most significant bit of the mantissa represents if NaN is signalling. As such, in assumption that all NaN's produced by the CPU have other bits set to zero (qNaN Indefinite on x86), it is possible to encode "tag" and "value" into that 50 spare bits. With pointer compression and custom memory allocator it is possible to ensure that even 64 bit pointers fit into that amount of memory.\\
As such, in manner of LuaJIT new ``foreign object'' tag is brought to represent statically typed objects. For accessing static fields, functions and constructors, same can be done with storing managed classes.

\section{Inline caches}
For purposes of optimization, most instructions have inline caches, that store information for speeding up execution, and then their data is used by an optimizing compiler as a profile info. For instance, \texttt{LdObjByName} bytecode instruction (which loads object property by it's constant name) stores a known dynamic class value and an integer representing offset. As such, when given value of this class it simply verifies that is is stored, and then loads 64 bits from the given address, instead of following all actions that a slow path does: verify that is is actually an object, or else throw a specific type error, then select object representation type: it can be either a linear array or a hash map, then find property in appropriate data structure and load it (updating inline cache).\\
Inline caches must be extended to be able to handle foreign objects. It is enough to store a field runtime descriptor, then add another ``slow path'' which follows similar scheme: verifies that given object is foreign, then checks that it is an instance of a class base field and then loads.\\
Notably, both functions and dynamic classes are non-movable and permanent, which implies same restrictions on profile data for foreign objects.

\section{Loading fields}
While from the first glance it may look as trivial as guarding for foreign object tag and instance of a given class, and then loading a field and boxing it into corresponding primitive value (\texttt{int32} or \texttt{float64}) or foreign object, few brand new optimizations come into place. Main optimization is shown in figure~\ref{fig:field-opt}: unboxing after boxing can be eliminated with few nuances. Firstly, boxed value must remain in safe state (if there were any) for purpose of usage in interpreter as it occupied virtual register $v_i$, if execution fallbacks there and this ``save state'' was not eliminated by further optimizations. Secondly, as a foreign object is a reference type, which can be moved by a garbage collector, it must also appear in save state, but as it does not belong to any actual registers, new ``bridge'' must be created. And finally, \texttt{IsInstance} check can be replaced with null check, because type is known at compile time. This optimization is necessary, because compiler relies on a static typing for static languages, where only not-null asserts are inserted. This null check can be eliminated using null-safety info from statically typed language, if it provides any.
\begin{figure}[H]
	\caption{Optimizing foreign objects boxing and unboxing.}\label{fig:field-opt}
	\centering
		\resizebox{\textwidth}{!}{
			\begin{tabular}{ |c|c| }
				\hline
				Before & After \\
				\hline
				\includesvg{build/res/dot/load-field-1.dot} & \includesvg{build/res/dot/load-field-2.dot} \\
				\hline
			\end{tabular}
		}
	\end{figure}

\section{Storing fields}
For storing fields of foreign objects, compiler must know semantics of casting values. For instance, conversion from \texttt{float64} to \texttt{int8} can be done with a number of semantics: it can be either truncating, or performed as in Java: firstly convert to \texttt{int32} with special rules (e.g if floating point value is greater than maximum representable by \texttt{int32} type, then it is set second) and then converted \texttt{int32} to narrower type.

\section{Method invocation from static side}
If multiple virtual machines for same language can coexist, which is almost obligatory because of single-thread limitations, and is used by electron for security reasons, then their handles must be known at points of language switching. This can be done in two ways: either by storing scripting language virtual machines in values gained from it's context, which requires additional boxing, or by exposing entire interface via machine handle itself. Either way, script method pointer, if saved to assign-once variable, can be optimized by JIT compiler. To avoid modifications of statically typed language compiler, this can be implemented as a special call instruction, which will appear only in handwritten bytecode, which will be called from compiled one as ``external''. With this approach JIT compiler will inline functions and produce same resulting assembly, keeping high-level language compiler unchanged.

\section{Method invocation from dynamic side}
Overloading is a tricky case: it is possible to collect profile which will collect all argument types at invocation point, but it will slow down execution of regular ecmascript programs without significant benefit. So strategy is to find the most generic overload if possible, or else do not inline this function call and fall back into interpreter-like intrinsic call. Overloading in dynamically typed languages is somewhat unsolved problem: Python, Ruby, php and ecmascript don't have it; typescript forces programmer to write single body and check types with runtime language constructs, such as \texttt{typeof}. Prolog, Erlang and Elixir allow overloading over arguments count, which can be implemented with simple name mangling.\\
Graal VM calls most-specific version, e.g. expression \texttt{f(1)} calls \texttt{f(int8)} over \texttt{f(int32)}. At first, this approach seems to be better, but is has significant downsides:\\
\begin{enumerate}
	\item Numeric literals are handled differently in different languages: if type inference is supported (which likely means that language doesn't support overloading), literal most likely will be represented as ``intSome'', i.e. \texttt{fromInteger 1 :: Num} in Haskell, or \texttt{comptime\_int} in Zig (which can be coerced to other types upon resolution). In Java, $1$ will be converted to int if it is placed in unknown context, so \texttt{f(1)} will call \texttt{f(int32)}, which means that after copying identical line semantics changed.
	\item Finding ``most narrow'' type means performing runtime checks on every call, which can't be avoided even with profile info, because if profile said that argument fits into \texttt{int16}, two (or four including lower and upper bounds) guards must be inserted: for both fitting \texttt{int16} and not fitting \texttt{int8}. Things are even worse when input value is a floating point.
\end{enumerate}
That said, in idiomatic code overloads are ``transparent'': programmer doesn't care if \texttt{print(int64)} or \texttt{print(int32)} was called, as they do semantically the same thing.

\section{Method invocation in general}
\TODO thread states

\section{Threads management}
Most popular dynamically typed languages either don't allow threads creation (Lua, ecmascript) or have a global interpreter lock (CPython, Ruby MRI). There are few that allow multithreading, and they are focused either on performance (Julia) or on distribution (Elixir, Erlang). Which brings us to a conclusion, that dynamic language should interact and be ran only in a single thread of a statically typed language. Similar limitations are imposed by many libraries, such as OpenGL.\\
Thread management is important for garbage collection, as it requires suspending all threads executing managed code during stop-the-world phases. Currently, there is a mix of threads and coroutines in implementation. As we are executing multiple thread states for different languages in a single native thread, now it requires suspending one and resuming other during this thread state switching. If coroutines (thread states) were separated from real threads, then suspension for garbage collection would boil down to suspending only actually running threads. Which means that ``thread state'' would be better if renamed to ``corotuine state''.

\section{Memory management}

\section{Garbage collection}
Garbage collection on Ark platform is mostly generalized, but some most low-level methods, that perform actual objects marking and traversing are statically parametrized with language config, which says if language is static or dynamic. For maximal reuse of existing code, existing structure can be modified in non-trivial way using virtual inheritance as shown in figure~\ref{fig:gc-markers}.\\
Initially, marking code asserted that class is either static or dynamic, based on context. This code should be modified with compile time check, that if context is not mixed, then insert this assert (which will be removed in release build mode), or else switch to opposite context. This way \texttt{Marker} can be ranamed to \texttt{MarkerImpl} with minimal modifications and without performance degradations for markers that exist in a single language context, if base is inherited correctly (i.e. non-virtually when it is not needed).\\
\begin{figure}[H]
\caption{Modification of markers hierarchy}\label{fig:gc-markers}
\centering
	\resizebox{\textwidth}{!}{
		\begin{tabular}{ |c|c| }
			\hline
			Old & New \\
			\hline
			\includesvg{build/res/dot/marker_was.dot} & \includesvg{build/res/dot/marker_new.dot} \\
			\hline
		\end{tabular}
	}
\end{figure}

\section{Challenges}
\subsection{Strings}
As their in memory layout is different, copying is required. As they are immutable in most languages, dynamically typed string may have a pointer to alternate string from a statically typed context, which will be lazily initialized on request.
\subsection{Arrays}
% https://wiki.python.org/jython/CollectionsIntegration
They face same problem as strings: types are not same, but from perspective of dynamically typed language it is mostly imperceptable, because of duck typing (if language-specific API is exposed). But things are worse for statically typed languages: dynamically typed array may contain any values, while statically typed only given subtypes. Also, covariance and contravariance is erased on level of bytecode, which can break statically typed language if handled incorrectly. Other implementations (jython) also forbid such conversions.
\subsection{Returning primitive types from dynamically typed functions}
\subsection{Inheritance}
\subsection{Null}
Attentive reader could notice, that type system extension with new tag on dynamic side introduced yet another \texttt{null} value.

\chapterconclusion
As we can see, there is always a tradeoff between performance and ease of use.

\chapter{RESULTS}

\chapterconclusion

В конце каждой главы желательно делать выводы. Вывод по данной главе~--- нумерация работает корректно, ура!

%% Макрос для заключения. Совместим со старым стилевиком.
\startconclusionpage

В данном разделе размещается заключение.

\printmainbibliography

%% После этой команды chapter будет генерировать приложения, нумерованные русскими буквами.
%% \startappendices из старого стилевика будет делать то же самое
\appendix

\chapter{Listings}
\begin{figure}[!h]
	\caption{Micro benchmark of function call in cppyy and python}\label{apx:cppyy-bench}
	%\centering
	\lstinputlisting[language=Python]{../data/cppyy-sample.py}
\end{figure}

\end{document}
