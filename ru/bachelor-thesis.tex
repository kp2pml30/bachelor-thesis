\documentclass[times,specification,annotation]{itmo-student-thesis}

%% Опции пакета:
%% - specification - если есть, генерируется задание, иначе не генерируется
%% - annotation - если есть, генерируется аннотация, иначе не генерируется
%% - times - делает все шрифтом Times New Roman, собирается с помощью xelatex
%% - languages={...} - устанавливает перечень используемых языков. По умолчанию это {english,russian}.
%%                     Последний из языков определяет текст основного документа.

%% Делает запятую в формулах более интеллектуальной, например:
%% $1,5x$ будет читаться как полтора икса, а не один запятая пять иксов.
%% Однако если написать $1, 5x$, то все будет как прежде.
%\usepackage{icomma}

%% Один из пакетов, позволяющий делать таблицы на всю ширину текста.
\usepackage{tabularx}

%% Данные пакеты необязательны к использованию в бакалаврских/магистерских
%% Они нужны для иллюстративных целей
%% Начало
\usepackage{svg}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage{filecontents}
\begin{filecontents}{bachelor-thesis.bib}
@online{ doerr-doerr-lambda-lambda-self-adjustment-arxiv,
	year        = {2015},
	title       = {Optimal Parameter Choices Through Self-Adjustment: Applying the 1/5-th Rule in
				   Discrete Settings},
	author      = {Benjamin Doerr and Carola Doerr},
	url         = {http://arxiv.org/abs/1504.03212},
	year        = {2015},
	langid      = {english}
}

@inproceedings{ example-english,
	year        = {2015},
	booktitle   = {Proceedings of IEEE Congress on Evolutionary Computation},
	author      = {Maxim Buzdalov and Anatoly Shalyto},
	title       = {Hard Test Generation for Augmenting Path Maximum Flow
				   Algorithms using Genetic Algorithms: Revisited},
	pages       = {2121-2128},
	langid      = {english}
}

@article{ example-russian,
	author      = {Максим Викторович Буздалов},
	title       = {Генерация тестов для олимпиадных задач по программированию
				   с использованием генетических алгоритмов},
	journal     = {Научно-технический вестник {СПбГУ} {ИТМО}},
	number      = {2(72)},
	year        = {2011},
	pages       = {72-77},
	langid      = {russian}
}

@article{ unrestricted-jump-evco,
	author      = {Maxim Buzdalov and Benjamin Doerr and Mikhail Kever},
	title       = {The Unrestricted Black-Box Complexity of Jump Functions},
	journal     = {Evolutionary Computation},
	year        = {2016},
	note        = {Accepted for publication},
	langid      = {english}
}

@book{ bellman,
	author      = {R. E. Bellman},
	title       = {Dynamic Programming},
	address     = {Princeton, NJ},
	publisher   = {Princeton University Press},
	numpages    = {342},
	pagetotal   = {342},
	year        = {1957},
	langid      = {english}
}

@online{ ignition-iterpreter,
	year        = {2018},
	title       = {Firing up the Ignition interpreter},
	author      = {v8 developers},
	url         = {https://v8.dev/blog/ignition-interpreter},
	langid      = {english}
}
\end{filecontents}
%% Конец

%% Указываем файл с библиографией.
\addbibresource{bachelor-thesis.bib}

\begin{document}

\newcommand{\TODO}{{ \color{red} TODO }}

\studygroup{M34361}
\title{Поддержка вызова функций и передачи объектов между реализациями языков со статическими и динамическими типизациями на платформе Ark}
\author{Прокопенко Кирилл Дмитриевич}{Прокопенко К.Д.}
\supervisor{Фильченков Андрей Александрович}{Фельченков А.А.}{кандидат физико-математических наук}{кандидат физико-математических наук}
\publishyear{2023}
%% Дата выдачи задания. Можно не указывать, тогда надо будет заполнить от руки.
\startdate{29}{декабря}{2022}
%% Срок сдачи студентом работы. Можно не указывать, тогда надо будет заполнить от руки.
\finishdate{31}{мая}{2023}
%% Дата защиты. Можно не указывать, тогда надо будет заполнить от руки.
\defencedate{15}{июня}{2023}

\addconsultant{Соломенников Д.И.}{без сетепени, без звания}

\secretary{Павлова О.Н.}

%% Задание
%%% Техническое задание и исходные данные к работе
\technicalspec{Требуется добавить возможность запускать скрипты из статически типизированного языка, вызывать функции и методы над статически типизированными объектами из динамического языка и наоборот, передавать объекты в обе стороны}

%%% Содержание выпускной квалификационной работы (перечень подлежащих разработке вопросов)
\plannedcontents{Пояснительная записка должна демонстрировать использование наиболее типичных конструкций, возникающих при составлении
пояснительной записки (перечисления, рисунки, таблицы, листинги, псевдокод), при этом должна быть составлена так, что демонстрируется
корректность работы стилевого файла. В частности, записка должна содержать не менее двух приложений (для демонстрации нумерации рисунков и таблиц
по приложениям согласно ГОСТ) и не менее десяти элементов нумерованного перечисления первого уровня вложенности (для демонстрации корректности
используемого при нумерации набора русских букв).}

%%% Исходные материалы и пособия
\plannedsources{\begin{enumerate}
	\item ГОСТ~7.0.11-2011 <<Диссертация и автореферат диссертации>>;
	\item С.М. Львовский. Набор и верстка в системе \LaTeX;
	\item предыдущий комплект стилевых файлов, использовавшийся на кафедре компьютерных технологий.
\end{enumerate}}

%%% Цель исследования
\researchaim{Исследование принципов межъязыкового взаимодействия и его поддержка на платформе Ark.}

%%% Задачи, решаемые в ВКР
\researchtargets{\begin{enumerate}
	\item обеспечение соответствия титульной страницы, задания и аннотации шаблонам, принятым в настоящее время на кафедре;
	\item обеспечение соответствия содержательной части пояснительной записки требованиям ГОСТ~7.0.11-2011 <<Диссертация и автореферат диссертации>>;
	\item обеспечение относительного удобства в использовании~--- указание данных об авторе и научном руководителе один раз и в одном месте, автоматический подсчет числа тех или иных источников.
\end{enumerate}}

%%% Использование современных пакетов компьютерных программ и технологий
\addadvancedsoftware{Пакет \texttt{tabularx} для чуть более продвинутых таблиц}{\ref{sec:tables}, Приложения~\ref{sec:app:1}, \ref{sec:app:2}}
\addadvancedsoftware{Пакет \texttt{biblatex} и программное средство \texttt{biber}}{Список использованных источников}

%%% Краткая характеристика полученных результатов
\researchsummary{Получился, надо сказать, практически неплохой стилевик. В 2015--2018 годах
его уже использовали некоторые бакалавры и магистры. Надеюсь на продолжение.}

%%% Гранты, полученные при выполнении работы
\researchfunding{Автор разрабатывал этот стилевик исключительно за свой счет и на
добровольных началах. Однако значительная его часть была бы невозможна, если бы
автор не написал в свое время кандидатскую диссертацию в \LaTeX,
а также не отвечал за формирование кучи научно-технических отчетов по гранту,
известному как <<5-в-100>>, что происходило при государственной финансовой поддержке
ведущих университетов Российской Федерации (субсидия 074-U01).}

%%% Наличие публикаций и выступлений на конференциях по теме выпускной работы
\researchpublications{По теме этой работы я (к счастью!) ничего не публиковал.
\begin{refsection}
Однако покажу, как можно ссылаться на свои публикации из списка литературы:
\nocite{example-english, example-russian}
\printannobibliography
\end{refsection}
}

%% Эта команда генерирует титульный лист и аннотацию.
\maketitle{Бакалавр}

%% Оглавление
\tableofcontents

%% Макрос для введения. Совместим со старым стилевиком.
\startprefacepage

Межъязыковое взаимодействие является важной технологией по нескольким причинам:

\begin{enumerate}
\item Сотрудничество: Когда несколько команд или разработчиков работают над одним проектом, им может быть удобно использовать разные языки программирования. Возможность их взаимодействия обеспечит, что эти языки могут бесшовно работать в одной программе, что повысит эффективность разработки.

\item Переиспользование: межъязыковое взаимодействие позволяет использовать ранее написанный код на другом языке программирования. Например, оно может сделать доступным графическую библиотеку, написанную на статически типизированном языке для вызова из динамически типизированного, без требования написания дополнительного кода или генерации некоторого ``клея''. Подобное может быть проделано и в обратную сторону: уже существующая библиотека может быть переписана на более быстром языке.

\item Гибкость: В то время, как многие языки программирования позиционируются как ``языки общего назначения'', это не значит, что они не подходят для некоторых задач лучше, чем для других. Например, языки, удовлетворяющие открытому стандарту ecmascript, популярны в сфере разработки графических интерфейсов. Не только из-за того что они были единственной альтернативой в браузерах на протяжении многих лет, но и благодаря упрощениям, которые дает динамическая типизация. Все перечисленное ведет к тому, что компаниям легче нанять специалиста на таком языке, нежели искать специалиста на других. Таким образом, возможность выбирать язык подходящий для задачи позволяет сделать решения более гибкими.
\end{enumerate}

В то время как межъязыковое взаимодействие не является решенной задачей, количество проектов, ставящих своей целью его упрощение указывает на спрос в данной сфере, который мог бы снизить стоимость производства программного обеспечения.

%% Начало содержательной части.
\chapter{Обзор}

\startrelatedwork
Пример ссылок в рамках обзора: \cite{example-english, example-russian, unrestricted-jump-evco, doerr-doerr-lambda-lambda-self-adjustment-arxiv}.

\section{Существующие решения}
\subsection{Нативный-нативный}
Взаимодействие языков в данной области сводится к поддержке совместимости с ABI\footnote{ABI~--- бинарный интерфейс приложения} языка C. Известные решения, зачастую, включают целые языки: C++ и Zig, которые, по сути, позволяют включать целые заголовочные файлы самого языка C. В случае C++ для функций необъодима пометка \texttt{extern "C"} для того чтобы отключить ``коверканье'' слов, а в языке Zig достаточно просто указать интринсик \texttt{@cInclude}, который разберет файл при помощи библиотеки clang и автоматически сгенерирует декларации на языке (однако, включение одного и того же файла два раза подряд может привести к несовместимости).

\subsection{Управляемый-нативный}
\subsubsection{JNI --- Java Native Interface}
Чтобы справится с двигающим сборщиком мусора, все указатели на объекты Java кучи помещаются в специальный массив, о котором знает сборщик мусора. В результате, нативный код взаимодействует только с косвенными указателями. Из-за того, что нативный код не гарантирует расстановку ``безопасных точек''\footnote{Safe point --- место в программе, где она может остановиться для некоторого этапа сборки мусора или деоптимизации. В частности, это означает, что известно расположение объектов в регистрах и на стеке.} с какой-либо регулярностью, на время всего исполнения нативного кода поток погружаетя в безопасное состояние, а все функции, обладающие доступом к Java куче, замедляются из-за того, что должны возвращаться из этого безопасного состояния. Для ускорения программ, существуют некоторые ``критические'' функции, такие как \texttt{GetPrimitiveArrayCritical}, которые дают настоящий указатель, но могут заблокировать все Java приложение до тех пор, пока этот указатель не будет освобожден.\\
Доступа из Java к нативной куче нет, что обязывает создавать нативные функции доступа, которые, в свою очередь, работают медленнее, чем ``аналогичные'' написанные на Java. К другим ограничениям, для нативных функций необходимо генерировать специальные заголовочные файлы.\\
\subsubsection{Project panama}
Проект старается бороться с ограничениями JNI: добавляет доступ из Java к объектам на нативной куче (условно, по указателям, но проще и безопаснее чем \texttt{sun.misc.Unsafe}), добавляет поддержку нативных функций с переменным числом аргументов (в Java они бы запаковались в массив, в то время как в нативном соглашении о вызовах передались бы в небезопасной манере: через регистры или стек, без контроля за числом аргументов, что, конечно, менее безопасно, однако имеет свои применения).\\
Декларация структур с нативным расположением полей может помочь и обычным Java приложениям, т.к. виртуальная машина имеет право переупорядочивать поля, а задание строгого расположения может помочь избежать, например, false sharing'а\footnote{false sharing~---ситуация, когда два потока обращаются по разным адресам памяти, которые, однако, расположены на одной кэш-линии, что приводит к ухудшению производительности}, за счет добавления неиспользуемых полей.
\subsubsection{LuaJIT}
Добавляет полноценный синтаксический анализатор деклараций языка C, благодаря чему расширяет типовую систему lua добавлением нового типа \texttt{cdata} в добавок к таблицам, числам и т.д. Данный подход позволяет вызывать нативные функции и обращаться к полям нативных структур с той же производительностью, что и изначальный язык --- C (за исключением проверок типов).
\subsubsection{CPPYY}
Позволяет вызывать различные конструкции языка C++ из питона при помощи использования проекта cling: интерпретатора и JIT компилятора C++, построенного на основе проекта LLVM. В то время, как он является удобной заменой автоматическим генератором ``клея'', и может быть использован для выноса крупных частей приложения на C++ для ускорения, он не устраняет стоимость вызова процедур в питоне, и может ее даже увеличивать за счет необходимости перепаковывать типы (например, \texttt{int} в питоне это большое число, но в рамках перехода между языками оно может быть преобразовано к \texttt{int} из C, что, на ряду с проверкой типов, будет требовать запаковку и распаковку). Замер скорости на маленькой программе в аппендиксе~\ref{apx:cppyy-bench} демонстрирует этот эффект.
\subsubsection{Haskell FFI}
Позволяет вызывать функции языка C с примитивами и указателями, что делает его крайне ограниченным и однонаправленным. Однако, есть возможность доступа к полям структур через смещение и размер, что, в сочетании с аппликативом, позволяет относительно удобно делать маршаллинг.

\subsection{Управляемый-управлемый}
\subsubsection{JVM/.NET}
Многие языки (такие как Kotlin) имеют относительно близкую к ``главному'' языку (Java или C\#) систему типов, что позволяет компилировать их в байткод виртуальной машины без значительной потери производительности. Другие же языки должны вносить компромиссы в свой дизайн, как, например, \texttt{null} значения в языке F\#, чтобы быть полностью совместимыми со старыми языками и позволить постепенную миграцию на допускающий меньшее число ошибок яык.
\subsubsection{Nashorn}
Nashorn это реализация стандарта ecmascript на JVM, которая использует исключения для создания деоптимизаций. В то время, как на простых мономорфных тестах данный проект может обогнать v8, на более сложных полиморфных примерах начинают становиться видны недостатки ``позитивных типов'' и нехватка динамического профиля.

\subsubsection{GraalVM}
Новейшая виртуальная машина, полагающаяся на мета-трассирующие оптимизации\footnote{подход, при котором создается интерпретатор дерева (потенциально, со специальными командами, о которых знает JIT компилятор), который затем компилируется}. Несмотря на удивительные результаты, данный подход имеет некоторые недостатки (о которых будет рассказано в секции \ref{sec:why-not-graal}), и не подходит для данной работы, поскольку она фокусируется на объединении двух уже существующих реализаций, которые имеют потенциально различные среды исполнения, наборы инструкций, представления объектов и даже размеры указателя, делающие их несовместимыми, и рассматривает возможные подходы именно при таких условиях.

%% Так помечается конец обзора.
\finishrelatedwork

\section{Что отличает платформу Ark?}
В одном процессе может существовать несколько виртуальных машин, реализации которых различны, но имеют общие компоненты. Например, сборщик мусора почти полностью унифицирован. Такой подход позволяет реализовать каждую виртуальную машину в наиболее эффективной манере с сохранением таких подходов как NaN запаковка, но не позволяет получить такое же простое взаимодействие языков на уровне байткода, как, например, JVM.

\section{Наивное решение}
Было бы возможно завернуть каждый объект статически типизированного языка в некоторый \texttt{Proxy}, который бы вызывал нативынй код среды выполнения, а она бы в свою очередь, за счет библиотеки рефлексии вызывала нужный метод или считывала поле. Однако, такое решение не только совершенно не эффективно (поскольку переключение контекста на нативный достаточно дорогая операция в сравнении с простым чтением поля объекта), но и ломало бы, например, рефлексивность равенства: чтение поля ссылочного типа каждый раз возвращало бы новый \texttt{Proxy} объект.

\chapter{Решение}
Их прочих решений, LuaJIT является ближайшим с динамически типизированной стороны: предлагается добавить новый тег в NaN упаковку, представляющий дерево типов ``инородных'' объектов (``foreign objects'' в коде и на некоторых схемах). Затем, эти типы интегрируются в интерпретатор и в inline кэши, которые так же используются как профиль при динамической компиляции, что позволяет внедрить новые оптимизации.\\
Т.к. данная работа фокусируется на изменениях среды исполнения, а большая часть статически типизированных языков полагается на компиляторную ``магию'' или ``синтаксический сахар'', эта часть будет освещена довольно поверхностно, покрывая только необходимые ``примитивы'', но не их представление в коде.

\section{Представление объектов на статически типизированной стороне}
Дерево типов должно быть немного модифицировано, путем добавления нового корня, и переподвешиванием к нему старого, как показано в фигуре~\ref{fig:statically-typed-tree}.
{fig:statically-typed-tree}.
\begin{figure}[!h]
	\caption{Модификация иерархии статически типизированного языка}\label{fig:statically-typed-tree}
	\centering
	\includesvg{build/res/dot/statically-typed-tree.dot}
\end{figure}
Проверки типов и их преобразования также должны отличаться от обычных, что связано с особенностями реализации: в обеих реализациях тип представляющий класс объекта наследует некоторый \texttt{BaseClass}, содержащий, например, информацию для сборщика мусора. Однако, это не позволяет ни использовать библиотеку рефлексии, ни преобразовывать их друг к другу, поскольку последующее представление в памяти уже различно. Необходимо добавить команду компилятора, читающую указатель на \texttt{BaseClass} и берущую флаги из нее, где указано динамический ли класс у объекта. Т.к. \texttt{Object} и \texttt{ScriptObject} никак не связаны, компилятору следует требовать преобразование через \texttt{SomeObject}, как это реализовано, например, в F\#. Преобразование к \texttt{SomeObject} может быть соблюдено без каких либо проверок, поскольку этот класс является лишь синтетической абстракцией, без какого-либо представления во время выполнения.\\
\texttt{ScriptObject} может иметь некоторые расширения, такие как доступ к свойствам через точку или квадратные скобки, который будет компилироваться в нечто особенное, или иметь большее число наследников для выражение лучшей типовой безопасности.

\section{Представление объекта на динамически типизированной стороне}
В динамически типизированных языках любое значение может быть представлено как указатель на некоторый \texttt{ObjectHeader}, однако, такой подход потребляет значительное количество памяти из-за необходимости постоянных аллокаций и индирекций, что может еще и привести к удлинению пауз сборщика мусора. Из-за этого многие реализации используют одну из двух стратегий: сжатие указателей (pointer compression) или NaN упаковка (NaN boxing). Платформа Ark использует второе. Эта текхника опирается на то, согалсно стандарту IEEE-754 число с плавающей точкой двойной точности представляется как экспонента из всех единиц, и единичный бит мантиссы тоже выставляется в единицу, чтобы сделать его не сигнализирующим. В предположении, что все NaN значения, которые может сгенерировать процессор имеют нулевую мантиссу (кроме бита на сигнализирующий ли, ``qNaN Indefinite'' на x86 процессоре), остаются не занятыми 50 бит, в которые можно поместить некоторый ``тег'' и ``значение''. При помощи сжатия указателя или специального аллокатора можно добиться того, чтобы любой указатель на управлемый объект помещался в это количество бит.\\
Таким образом, для представления инородных объектов можно ввести новый тег, по которому будет храниться ссылка на статически типизированный объект. Для представления же статических сущностей, можно сделать небольшую ``перегрузку'' этой семантики: ввести специальное поведение для случая, когда хранимая ссылка указывает на \texttt{Class} (объект, представляющий тип).

\section{Inline кэши}
Для ускорения выполнения некоторых инструкций, они имеют встраиваемые кэши, данные из которых затем используются оптимизирующим компилятором как профиль. Например, инструкция байткода \texttt{LdObjByName}, которая загружает свойство объекта по константному имени, сохраняет в себе динамический класс и число, представляющее смещение на искомое поле в нем. Таким образом, сначала кэш пустой, и во врмя исполнения необходимо узнать данные о классе: он представляется массивом или хэш-таблицей, затем при помощи подходящего алгоритма найти искомое значение ключа, обновить inline кэш и загрузить запрашиваемое значение. При повторном выполнении будет достаточно сравнить класс и сразу же загрузить значение в случае его совпадения, без совершения всех длительных действий и обращений к структурам данных, которые совершает медленный путь исполнения.\\
Встраиваемые кэши должны быть расширены для поддержки инородных объектов за счет добавления еще одного медленного пути: проверки что объект инородный, проверки что его класс расширяет хранимый, и загрузки поля, которое хранится как указатель на представление внутри виртуальной машины, поскольку необходимо также знать тип и размер этого поля, в отличие от динамически типизированного случая, где все объекты занимают 64 бита и хранят NaN упакованное значение.\\
Можно заметить, что и функции и типы, изначально хранимые во встраиваемых кэшах изначально были неподвижными (для сборщика мусора) и с бесконечным временем жизни, т.к. это необходимо для работы асинхронного JIT компилятора. Из-за чего и новые данные, хранимые там так же должны удовлетворять этим свойствам, что добавляет новый класс корневых объектов ко всей виртуальной машине.

\section{Загрузка полей}
В то время, как на первый взгляд может показаться, что достаточно просто вставлять проверку на инородный тег, расширение известного класса, а затем запаковывать полученное значение в соответствующее примитивное (\texttt{int32}, \texttt{float64}, \texttt{bool}) или очередной инородный объект, несколько новых оптимизаций необходимы. Основная из них продемонстрирована в фигуре~\ref{fig:field-opt}: удаление распаковки после запаковки с несколькими нюансами. Во-первых, запакованное значение должно остаться в ``безопасном состоянии''\footnote{save state---состояние, где известно какие регистры и адреса на стеке соответсвуют какому состоянию интерпретатора: регистрам, стеку и номеру инструкции интерпретатора. Из этого состояния может произойти деоптимизация или сборка мусора}, потому что занимает некоторый виртуальный регистр $v_i$, который может быть использован в случае дальнейшей деоптимизации. Однако, эта лишняя ``запаковка'' вероятно будет удалено при последующих оптимизациях, если они сочтут это безопасное состояние не используемым. Во-вторых, т.к. инородный объект это ссылочный тип, его в незавернутом состоянии тоже необходимо положить в последующее безопасное состояние, чтобы в случае сборки мусора сслыка на него обновилась. Т.к. ему не соответсвует ни один виртуальный регистр, он помещается в так называемый мост (bridge). И, наконец, последующие проверки на принадлежность к классу (\texttt{IsInstance}) могут быть статически изменены на проверки на \texttt{null}, поскольку JIT компилятор изначально полагается на компилятор статически типизированного языка, и в аналогичном коде двойного доступа к полю вставляет только проверки на нулевой указатель, но не на тип операнда. Эта проверка на нулевой указатель может быть и дальше удалена за счет информации о типах из статически типизированного языка, если он ее предоставляет, или заменена на обработку сигнала операционной системы.

\begin{figure}[H]
	\caption{Оптимизация запаковки и распаковки инородных объектов.}\label{fig:field-opt}
	\centering
		\resizebox{\textwidth}{!}{
			\begin{tabular}{ |c|c| }
				\hline
				Before & After \\
				\hline
				\includesvg{build/res/dot/load-field-1.dot} & \includesvg{build/res/dot/load-field-2.dot} \\
				\hline
			\end{tabular}
		}
	\end{figure}

\section{Сохранение полей}
Для сохранения полей инородных объектов компилятор должен знать семантику преобразования значений. Например, конверсия из \texttt{float64} в \texttt{int8} может быть сделана несколькими способами: при помощи усечения, как в C++ (инструкция \texttt{cvttsd2si} на процессоре x86-64), или с семантикой аналогичной Java: сначала происходит преобразование к \texttt{int32} со специальными правилами (например, если значение числа с плавающей точкой больше максимального допустимого, то результат считается равным второму), и затем полученный \texttt{int32} конвертируется к числу меньшей битности.\\
В остальном сохранение полей полностью аналогично их загрузке.

\section{Управление потоками} \label{sec:thread-management}
Большинство динамически типизированных языков либо не позволяют создавать потоки (Lua, ecmascript), либо имеют глобальный лок интерпретатора (CPython, Ruby MRI). Есть несколько языков с поддержкой многопоточности, но они либо фокусируются на производительности (Julia), либо построены вокруг распределенности (Erlang, Elixir, в которых даже сборщик мусора работает внутри одного потока). Из этого следует, что динамический язык должен взаимодействовать и выполняться только на одном реальном потоке. На самом деле, это довольно распространенное ограничение, которое имеется так же в библиотеках на подобие OpenGL.\\
Управление потоками важно для сборки мусора, поскольку существуют фазы ``остановки мира''\footnote{англ. stop-the-world}, в которые все потоки выполняющие управляемый код должны остановиться. Это может быть реализовано за счет, например, read-write лока: исполняемые потоки берут право на чтение, а желающий их остановить на запись, и тогда его попадание в критическую секцию будет означать, что все потоки остановлены. Из-за того, что необходимо выполнять два состояния потока разных языков на одном реальном, принадлежащем операционной системе, может возникнуть путаница или неправильное количество держателей лока на чтение, и ``правильной'' архитектурой было бы иметь отдельно потоки выполнения которые бы исполняли корутины.

\section{Вызов методов}

\section{На статически типизированной стороне}
Если несколько виртуальных машин для одного языка могу сосуществовать, что является практически обязательным, при условии что они все привязаны к своему потоку, и могут быть нужны в целях безопасности, как, например фреймворк Electron разделяет контекст в котором происходит отрисовка, от контекста с логикой, то необходимо везде передавать указатель на виртуальную машину (в терминологии v8---isolate). Этого можно достигнуть двумя способами: либо заворачивать все объекты в дополнительную прослойку, которая будет знать о привязанной вирутальной машине, либо совершать все взаимодействие через переменную, предоставляющую к ней доступ. Второй способ является более производительным, поскольку не требует дополнительных выделений памяти, но усложняет добавление синтаксического сахара для работы с динамическими объектами, возможно добавление некоторого аналога \texttt{with} из языка программирования Kotlin.\\
В любом из описанных случаев, если указатель сохраняется в переменную с единственным присваиванием, то он потенциально может быть оптимизирован JIT компилятором. Чтобы избежать модификаций компилятора статически типизированного языка, это может быть представлено как вызов внешней функции, содержащей специальную инструкцию вызова, тогда после фазы инлайнинга получится идентичное промежуточное представление.

\subsection{на динамически типизированной стороне}
Перегрузка функций и методов это довольно сложный случай: возможно собрать профиль типов аргументов в точке вызова, однако это замедлит выполнение в случае, когда межъязыковое взаимодействие не используется, без особых преимуществ, в то время как хотелось бы следовать принципу ``not pay for what you don't use''\footnote{англ. не плати за то, что не используешь}. Таким образом, наиболее выгодная стратегия? это найти наиболее общую перегрузку, или, если ее не существует, вернуться к исходному уровню компиляции\footnote{англ. baseline~--- компиляция из байткода 1 в 1, без применения оптимизаций, зачастую сводится к вызову интринсика}.\\
Такой, казалось бы, плохой уровень связан с тем, что перегрузка в динамических языках это не решенная проблема: Python, Ruby и ecmascript обязывают писать исключительно одну реализацию функции. Typescript позволяет сделать несколько ``перегрузок'', однако они все будут иметь общее тело, и будут разрешаться за счет динамических конструкций языка, таких как \texttt{typeof}. Пролог, Erlang и Elixir разрешают перегрузку по числу аргументов, что может быть представлено как просто функции с разными называниями; обычно арность в них записывается через \texttt{/} после имени функции.
Graal VM вызывает самую специфическую версию, таким образом, \texttt{f(1)} вызывает \texttt(f(int8)), а не \texttt{f(int32)}. На первый взгляд может показаться, что такой подход лучше, однако он имеет значительные недостатки:\\
\begin{enumerate}
	\item Численные литералы по-разному обрабатываются в языках программирования: если в какой-то степени поддерживается вывод типов (в случае чего язык почти наверняка не поддерживает уже перегрузку), литерал скорее всего представляется как \texttt{intSome}, например \texttt{fromInteger 1 :: Num} в языке программирования Haskell, или \texttt{comptime\_int} в Zig'е. Этот тип затем может быть преобразован к нужному во время решения системы уравнений о типах. В Java, $1$ представляет собой литерал типа \texttt{int}, а значит \texttt{f(1)} вызовет именно \texttt{f(int32)}, а не от более узкого типа, что означает, что при простом переносе строчки из статически типизированного языка в динамически типизированный изменилась семантика.
	\item Нахождение ``самой конкретной специализации'' означает добавление нескольких проверок во время исполнения, которых невозможно избежать за счет сбора профиля, поскольку даже если он говорит, что число поместиться в \texttt{int16}, это необходимо проверить, и в добавок к этому убедиться, что оно не помещается в \texttt{int8}. Если в языке присутствуют типы без знака, то картина усложняется еще сильнее, и становится совсем не понятно что выбирать, например, число $16$ должно вызвать функцию от целого числа без знака или со знаком? Если же на вход подается число с плавующей точкой, также необходимо проверить является ли оно целым.
	\item Такой вызов перегрузки в некотором смысле навязывает динамически типизированному языку чужую типизацию, ведь если в его системе есть только один численный тип~--- число с плавающей точкой двойной точности, то выглядит логичным вызвать перегрузку именно от него.
\end{enumerate}
При всем выше сказанном, перегрузки по большей части ``прозрачны'': программисту не важно вызовется \texttt{print(int64)} или \texttt{print(int32)}, т.к. семантически они делают одно и то же.

\subsection{в целом}
Как сказано в секции \ref{sec:thread-management}, у каждого языка есть свое ``состояние потока''. Во время интерпретации оно хранится в переменной локальной для каждого потока операционной системы и должен быть переприсвоен при каждом пересечении языковой границы, поскольку к нему обращаются различные части среды исполнения. В скомпилированном коде указатель на это состояние лежит в регистре, и передается из функции в функцию по соглашению о вызовах. Тогда, изменение может быть закодировано как обычный \texttt{mov} известной константы до и после вызова. Однако, раньше данный регистр хранил константу, благодаря чему был полностью когерентен с локальной переменной, а теперь при переходе из скомпилированного кода в интерпретатор или среду исполнения, значения могут быть не согласованы. Этого можно избежать, если сохранить указатель на локальную переменную внутрь состояния потока в момент его создания или первого присвоения, и тогда можно будет обновлять переменную в ``мосту'' из скомпилированного кода за счет дополнительной пары \texttt{mov} инструкций. Данный подход не порождает гонок данных, благодаря тому что оба состояния потока выполняются строго на одном ``реальном''.

\section{Управление памятью}

\section{Сборка мусора}
\subsection{``Маркеры''}
Сборка мусора на платформе Ark по большей степени обобщена, однако самые низкоуровневые примитивы, которые, например, размечают и обходят объекты обязаны быть разными. Они параметризованы конфигурацией языка, которая, помимо прочего, указывает динамический ли язык. Для максимального переиспользования кода, данная структура может быть применено нетривиальное (и потенциально вирутальное) наследование, как показано в фигуре~\ref{fig:gc-markers}.\\
Изначально, код размечающий объекты имел \texttt{assert}, что класс полученного объекта соответсвует контексту, и эта проверка удалялась в итоговой сборке платформы, поскольку включала атомарное чтение и условие в коде, который может выполняться десятки тысяч раз. Таким образом, чтобы не ``переплачивать'', если конфигурация (уже не языка, а платформы) указывает, что разрешено межъязыковое взаимодействие, то вставлять проверку и переключать маркер на статический режим, а иначе вызывать \texttt{assert}, который будет удален. Можно выдвинуть гипотезу, что переключение контекста происходит крайне редко, и подсказать это компилятору через встроенные команды.\\
Таким образом, \texttt{Marker} может быть переименован в \texttt{MarkerImpl} с минимальными изменениями и без ухудшений производительности в случае, когда с данным сборщиком мусора может исполняться только один язык.
\begin{figure}[H]
\caption{Модификация иерархии маркеров}\label{fig:gc-markers}
\centering
	\resizebox{\textwidth}{!}{
		\begin{tabular}{ |c|c| }
			\hline
			Old & New \\
			\hline
			\includesvg{build/res/dot/marker_was.dot} & \includesvg{build/res/dot/marker_new.dot} \\
			\hline
		\end{tabular}
	}
\end{figure}
\subsection{Iterating stacks}
As stack-iterating depends only on type of method (dynamic/static), which is stored in every frame, modifications of stack scanning are not needed. However, as two ``thread states'' share same stack, additional check, that checks that state is topmost must be added. It can be performed using that ``address'', i.e. value located in that thread local variable equals to examined thread. As they are accessed only during stop-the world phases (such as ``initial mark pause'' and ``remark pause''), it does not introduce data race.
\subsection{Keeping references}
Fields and classes data, stored in profile info must be non-movable, because just in time compiler works concurrently and doesn't have access to runtime, and may be permanent, to keep equality semantics. To implement this, new virtual-machine level root objects are added, that map pointers to NaN boxed values.

\section{Challenges}
\subsection{Strings}
As their in memory layout is different, copying is required. As they are immutable in most languages, dynamically typed string may have a pointer to alternate string from a statically typed context, which will be lazily initialized on request. Other transformation can't be performed, because statcally typed language is ``main'' and may have few controlled virtual machines, or be multithreaded.
\subsection{Arrays}
% https://wiki.python.org/jython/CollectionsIntegration
They face same problem as strings: types are not same, but from perspective of dynamically typed language it is mostly imperceptible, because of duck typing (if language-specific API is exposed). But things are worse for statically typed languages: dynamically typed array may contain any values, while statically typed only given subtypes. Also, covariance and contravariance is erased on level of bytecode, which can break statically typed language if handled incorrectly. Other implementations (jython) also forbid such conversions.
\subsection{Returning primitive types from dynamically typed functions}
As \texttt{any} type can't be stored on statically typed side, one of following strategies can be used:\\
\begin{itemize}
	\item always return instance of some \texttt{TaggedValue}, which has two fields: one of type \texttt{uint64} to hold original \texttt{any} value (which may be invalidated in case of a reference type, but tag will remain same) and field of type \texttt{SomeObject} (with null value for primitive return types). Providing functions to pattern match on tags will cover all use cases
	\item in case of primitive types, return their ``boxed'' version. While in former case we could make that ``return value'' first argument and avoid allocation, here creating a small object is inevitable. As well, it is not trivial how to handle other ``empty'' values (such as \texttt{undefined}), they can be either coerced to null (as they usually represent \texttt{void} return type, which boxed version has only one valid value~--- null) or return preallocated objects, as \texttt{Unit} in Kotlin. Performing type checks on boxed types is as simple as asserting not-null, loading class value and comparing to a constant, as their classes are sealed.
\end{itemize}
\subsection{Inheritance}
\subsection{Null}
Attentive reader could notice, that type system extension with new tag on dynamic side introduced yet another \texttt{null} value, which shows flaws of NaN-boxing approach compared to one used by Graal VM: plain boxing to Java's ``boxed'' types.

\chapterconclusion
Можно заметить, что зачастую ставится вопрос о выборе между производительностью и удобством использования.

\chapter{Результаты}

\section{Преимущества наличия разных наборов инструкций и сред исполнения} \label{sec:why-not-graal}
В то время, как проекты, такие как Graal VM оптимизируют скорость разработки языка программирования, и при этом не теряют пиковую скорость производительности, к сожалению, реальным крупным проектам важны и другие характеристики, такие как потребляемое пространство, время загрузки и скорость интерпретации. Наличие целого абстрактного дерева и его интерпретация может быть не позволительна, например, в браузерах на мобильных платформах. Это подробно обсуждается в презентации по добавлению интерпретатора ignition в v8 \cite{ignition-iterpreter}
% https://v8.dev/blog/cost-of-javascript-2019

\section{Benchmarks}
\TODO

\chapterconclusion

В конце каждой главы желательно делать выводы. Вывод по данной главе~--- нумерация работает корректно, ура!

%% Макрос для заключения. Совместим со старым стилевиком.
\startconclusionpage
В ходе выполнения работы были получены следующие результаты:
\begin{enumerate}
	\item был проведен обзор области, покрывающий многочисленное число существующих решений для различных языков и платформ.
	\item было предложено решение для каждой компоненты виртуальной машины, участвующей в процессе, включая управление памятью, интерпретатор и компилятор
	\item код, демонстрирующий применимость предложенного подхода был написан и опубликован
	\item была проведена оценка результатов при помощи замеров производительности\TODO
\end{enumerate}


\printmainbibliography

%% После этой команды chapter будет генерировать приложения, нумерованные русскими буквами.
%% \startappendices из старого стилевика будет делать то же самое
\appendix

\chapter{Listings}
\begin{figure}[!h]
	\caption{Micro benchmark of function call in cppyy and python}\label{apx:cppyy-bench}
	%\centering
	\lstinputlisting[language=Python]{../data/cppyy-sample.py}
\end{figure}

\end{document}
