\documentclass[times,specification,annotation]{itmo-student-thesis}

%% Опции пакета:
%% - specification - если есть, генерируется задание, иначе не генерируется
%% - annotation - если есть, генерируется аннотация, иначе не генерируется
%% - times - делает все шрифтом Times New Roman, собирается с помощью xelatex
%% - languages={...} - устанавливает перечень используемых языков. По умолчанию это {english,russian}.
%%                     Последний из языков определяет текст основного документа.

%% Делает запятую в формулах более интеллектуальной, например:
%% $1,5x$ будет читаться как полтора икса, а не один запятая пять иксов.
%% Однако если написать $1, 5x$, то все будет как прежде.
%\usepackage{icomma}

%% Один из пакетов, позволяющий делать таблицы на всю ширину текста.
\usepackage{tabularx}

\usepackage{svg}
\usepackage{tikz}
\usetikzlibrary{arrows}
%\usepackage{filecontents}
\usepackage{bibentry}

\begin{filecontents}[overwrite]{bachelor-thesis.bib}
%@article{ example-russian,
%	author      = {Максим Викторович Буздалов},
%	title       = {Генерация тестов для олимпиадных задач по программированию
%				   с использованием генетических алгоритмов},
%	journal     = {Научно-технический вестник {СПбГУ} {ИТМО}},
%	number      = {2(72)},
%	year        = {2011},
%	pages       = {72-77},
%	langid      = {russian}
%}
%
%@book{ bellman,
%	author      = {R. E. Bellman},
%	title       = {Dynamic Programming},
%	address     = {Princeton, NJ},
%	publisher   = {Princeton University Press},
%	numpages    = {342},
%	pagetotal   = {342},
%	year        = {1957},
%	langid      = {english}
%}

@inproceedings{ one-vm-to-rule-them-all,
	doi = {10.1145/2509578.2509581},
	url = {https://doi.org/10.1145/2509578.2509581},
	year = {2013},
	month = oct,
	publisher = {{ACM}},
	author = {Thomas W\"{u}rthinger and Christian Wimmer and Andreas W\"{o}{\ss} and Lukas Stadler and Gilles Duboscq and Christian Humer and Gregor Richards and Doug Simon and Mario Wolczko},
	title = {One {VM} to rule them all},
	booktitle = {Proceedings of the 2013 {ACM} international symposium on New ideas,  new paradigms,  and reflections on programming and software}
}

@online{ what-i-learned-from-lua-jit,
	year        = {2016},
	title       = {What I learned from LuaJIT},
	author      = {Vyacheslav Egorov},
	url         = {https://www.youtube.com/watch?v=EaLboOUG9VQ},
	langid      = {english}
}

@online{ ignition-iterpreter,
	year        = {2018},
	title       = {Firing up the Ignition interpreter},
	author      = {v8 developers},
	url         = {https://v8.dev/blog/ignition-interpreter},
	langid      = {english}
}

@online{ luajit,
	year        = {2023},
	title       = {Lua jit},
	author      = {luajit developers},
	url         = {https://luajit.org/ext_ffi.html},
	langid      = {english}
}

@online{ golang-stack,
	year        = {2014},
	title       = {How Stacks are Handled in Go},
	author      = {Daniel Morsing},
	url         = {https://blog.cloudflare.com/how-stacks-are-handled-in-go/},
	langid      = {english}
}

@online{ v8-pointer-tagging,
	year        = {2020},
	title       = {Pointer Compression in V8},
	author      = {Igor Sheludko, Santiago Aboy Solanes},
	url         = {https://v8.dev/blog/pointer-compression},
	langid      = {english}
}

@online{ torque,
	year        = {2023},
	title       = {V8 Torque user manual},
	author      = {v8 contributors},
	url         = {https://v8.dev/docs/torque},
	langid      = {english}
}

@online{ erlang-gc,
	year        = {2023},
	title       = {Erlang Garbage Collector},
	author      = {Ericsson AB},
	url         = {https://www.erlang.org/doc/apps/erts/garbagecollection},
	langid      = {english}
}

@book{java8-spec,
  address = {Upper Saddle River, NJ},
  author = {Gosling, James and Joy, Bill and Steele, Guy L. and Bracha, Gilad and Buckley, Alex},
  biburl = {https://www.bibsonomy.org/bibtex/2e93895f98a08e3e26fcfc2e2d4673370/flint63},
  description = {1. Auflage 1996},
  edition = 5,
  file = {Oracle eBook:2014/GoslingJoyEtAl14.pdf:PDF;InformIT Product page:http\://www.informit.com/title/013390069X:URL;Amazon Search inside:http\://www.amazon.de/gp/reader/013390069X/:URL;Safari:https\://www.safaribooksonline.com/library/view/the-java-virtual/9780133922745/:URL},
  groups = {public},
  isbn = {978-0-13-390069-9},
  keywords = {01841 103 book shelf safari software java},
  publisher = {Addison-Wesley},
  series = {Java Series},
  title = {The Java Language Specification: Java SE 8 Edition},
  url = {http://docs.oracle.com/javase/specs/},
  username = {flint63},
  year = 2014
}

\end{filecontents}
%% Конец

%% Указываем файл с библиографией.
\addbibresource{bachelor-thesis.bib}

\lstdefinelanguage{etspseudo}{
	keywords={let, const, typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
	keywordstyle=\color{blue}\bfseries,
	ndkeywords={class, export, boolean, throw, implements, import, this, void, int, long, short, double},
	ndkeywordstyle=\color{purple}\bfseries,
	identifierstyle=\color{black},
	sensitive=false,
	comment=[l]{//},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{purple}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	morestring=[b]',
	morestring=[b]"
}
\lstset{
	showtabs=false,
	breaklines=true,
	language=etspseudo,
}

\begin{document}

\tikzstyle{every picture}+=[remember picture]
\tikzstyle{na}=[shape=rectangle,inner sep=0pt,text depth=0pt]

\newcommand{\TODO}{{ \color{red} TODO }}

\studygroup{M34361}
\title{Поддержка вызова функций и передачи объектов между реализациями языков со статическими и динамическими типизациями на платформе Ark}
\author{Прокопенко Кирилл Дмитриевич}{Прокопенко К.Д.}
\supervisor{Беляев Евгений Александрович}{Беляев Е.А.}{кандидат технических наук}{факультет ИТиП, доцент}
\publishyear{2023}
%% Дата выдачи задания. Можно не указывать, тогда надо будет заполнить от руки.
\startdate{29}{декабря}{2022}
%% Срок сдачи студентом работы. Можно не указывать, тогда надо будет заполнить от руки.
\finishdate{31}{мая}{2023}
%% Дата защиты. Можно не указывать, тогда надо будет заполнить от руки.
\defencedate{15}{июня}{2023}

\addconsultant{Соломенников Д.И.}{без сетепени, без звания}

\secretary{Павлова О.Н.}

%% Задание
%%% Техническое задание и исходные данные к работе
\technicalspec{Требуется добавить на платформу Ark возможность запускать скрипты из статически типизированного языка, вызывать функции и методы над статически типизированными объектами из динамического языка и наоборот, передавать объекты в обе стороны}

%%% Содержание выпускной квалификационной работы (перечень подлежащих разработке вопросов)
\plannedcontents{Пояснительная записка должна содержать исследование существующих решений в области межъязыкового взаимодействия и предлагать новое композитное решение, подходящее для платформы Ark. В нем должны поддерживаться вызовы методов и передача объектов на равне с их конструированием. Взаимодействие между вирутальными машинами должно проиходить с минимальным использованием нативного кода или оберток. Требуется валидация и проверка результатов как с точки зрения корректности, так и с точки зрения производительности.}

%%% Исходные материалы и пособия
\plannedsources{\begin{enumerate}
	\item \fullcite{one-vm-to-rule-them-all};
	\item \fullcite{what-i-learned-from-lua-jit};
	\item внутренняя документация компании по работе с платформой Ark.
\end{enumerate}}

%%% Цель исследования
\researchaim{Исследование возможностей и способов добавления взаимодействия языков с различными типизациями в седу исполнения на платформе Ark.}

%%% Задачи, решаемые в ВКР
\researchtargets{\begin{enumerate}
	\item исследование существующих решений в области межъязыкового
	взаимодействия;
	\item выделение затрагиваемых компонент платформы и их ограничений;
	\item проектирование интерфейса межъязыкового взаимодействия;
	\item реализация прототипа, минимизирующего количество неуправляемого кода;
	\item оценка результатов.
\end{enumerate}}

%%% Использование современных пакетов компьютерных программ и технологий
%\addadvancedsoftware{Пакет \texttt{tabularx} для чуть более продвинутых таблиц}{\ref{sec:tables}, Приложения~\ref{sec:app:1}, \ref{sec:app:2}}
%\addadvancedsoftware{Пакет \texttt{biblatex} и программное средство \texttt{biber}}{Список использованных источников}

%%% Краткая характеристика полученных результатов
\researchsummary{Было предложено композитное рещение и реализован работоспособный прототип, демонстрирующий как изменения каждой из компонент, так и реализацию обобщенного интерфейса межъязыкового взаимодействия и позволяющий улучшить производительность в некоторый случаях.}

%%% Гранты, полученные при выполнении работы
\researchfunding{Данная работа выполнялась во время работы в некоторой компании. Гранты получены не были.}

%%% Наличие публикаций и выступлений на конференциях по теме выпускной работы
\researchpublications{По теме работы в данный момент ничего не опубликовано. Однако, она была представлена на XII Конгрессе Молодых Ученых в ИТМО.
\begin{refsection}
%\nocite{example-english, example-russian}
\printannobibliography
\end{refsection}
}

\maketitle{Бакалавр}
\tableofcontents

\startprefacepage

Межъязыковое взаимодействие является важной технологией по нескольким причинам:

\begin{enumerate}
\item переиспользование кода: межъязыковое взаимодействие позволяет использовать ранее написанный код на другом языке программирования. Например, оно может сделать доступным графическую библиотеку, написанную на статически типизированном языке для вызова из динамически типизированного, без требования написания дополнительного кода или генерации некоторого ``клея''. Подобное может быть проделано и в обратную сторону: уже существующая библиотека может быть переписана на более быстром языке. Переиспользование кода может быть полезно и для постепенной миграции кодовой базы на другой язык;

\item гибкость: в то время, как многие языки программирования позиционируются как ``языки общего назначения'', это не значит, что они не подходят для некоторых задач лучше, чем для других. Например, языки, удовлетворяющие открытому стандарту ecmascript, популярны в сфере разработки графических интерфейсов не только из-за того, что они были единственной альтернативой в браузерах на протяжении многих лет, но и благодаря упрощениям, которые дает динамическая типизация. Все перечисленное ведет к тому, что компаниям легче нанять специалиста на таком языке, нежели искать специалиста на других. Таким образом, возможность выбирать язык подходящий для задачи позволяет сделать решения более гибкими;

\item сотрудничество: Когда несколько команд или разработчиков работают над одним проектом, им может быть удобно использовать разные языки программирования. Возможность их взаимодействия обеспечивает бесшовную работу в одной программе, что повышает эффективность разработки.
\end{enumerate}

Перечисленные пункты для компаний влекут финансовую прибыль, т.к. ускоряют разработку и упрощают найм сотрудников, т.е. снижают стоимость производства программного обеспечения.\\
В то время, как межъязыковое взаимодействие не является полностью решенной задачей, количество проектов, ставящих своей целью его упрощение, указывает на спрос в данной сфере.\\

Таким образом, целью данной работы является исследование возможностей и способов добавления взаимодействия языков со статическими и динамическими типизациями в среду исполнения на платформе Ark с минимизацией неуправляемого кода.\\
Задачи:
\begin{enumerate}
	\item исследование существующих решений в области межъязыкового взаимодействия;
	\item выделение и модификация затрагиваемых компонент платформы;
	\item проектирование архитектуры межъязыкового взаимодействия;
	\item реализация прототипа с минимизацией нативного и неуправляемого кода;
	\item оценка результатов.
\end{enumerate}

\chapter{Обзор}

\section{Термины и понятия}
В данной секции представлены термины, используемые в других частях представленной работы. В дальнейшем приведенные понятия будут использоваться в указанных значениях, если не указано обратное.
\def\MakeTerm#1#2{#1~-- #2.\\}
\subsection{Специфичные для области термины}
	\MakeTerm{Управляемый код (managed code)}{код, исполняемый под управлением виртуальной машины}
	\MakeTerm{Управляемый язык}{язык, все исполнение которого происходит под управлением виртуальной машины}
	\MakeTerm{NaN упаковка (nan boxing)}{подход к представлению данных, позволяющий избежать аллокаций. Более подробное описание представлено в секции~\ref{nan-boxing-explanation}}
	\MakeTerm{Деоптимизация (deoptimization)}{процесс возвращения из скомпилированного кода в интерпретируемый в случае, когда какое-то предположение оказалось неверным. При этом скомпилированный код может быть инвалидирован}
	\MakeTerm{Встраиваемые кэши (inline caches)}{оптимизация интерпретаторов динамических языков, позволяющая ускорять выполнение некоторых инструкций за счет кэширования прошлых результатов}
	\MakeTerm{Интринсик (intrinsic)}{встроенная в компилятор специальная команда}

\subsection{Аббревиатуры}
	\MakeTerm{ABI (Application Binary Interface)}{бинарный интерфейс приложения: соглашение по которому машинный код интерпретирует данные}
	\MakeTerm{JIT компиляция (Just in Time compilation)}{подход, при котором программа компилируется во время исполнения}
	\MakeTerm{AOT компиляция (Ahead of Time compilation)}{подход, при котором программа компилируется один раз перед исполнением}
	\MakeTerm{JVM (Java Virtual Machine)}{конкретная спецификация виртуальной машины}
	\MakeTerm{м8}{конкретная виртуальная машина реализющая стандарт ecmascript}
	\MakeTerm{FFI (Foreign Function Interface)}{интерфейс позволяющий вызывать функции из динамической библиотеки написанные на другом языке}

\startrelatedwork

\section{Существующие решения}
Все существующие решения можно разбить на три категории по признаку ``управляемости'' взаимодействующих языков, которые будут рассмотрены ниже.

\subsection{Нативный-нативный}
Взаимодействие языков в данной области зачастую сводится к поддержке совместимости с ABI языка C. Известные решения зачастую, включают целые языки: C++ и Zig, которые, по сути, позволяют включать целые заголовочные файлы самого языка C. В случае C++ для функций необходима пометка \texttt{extern "C"} для того чтобы отключить ``коверканье'' имен глобальных символов, а в языке Zig достаточно просто указать интринсик \texttt{@cInclude}, который разберет заголовочный файл при помощи библиотеки clang и автоматически создаст в памяти декларации, понимаемые языком Zig (однако, включение одного и того же файла два раза подряд может привести к несовместимости с точки зрения типовой системы).

\subsection{Управляемый-нативный}
\subsubsection{JNI --- Java Native Interface}
Чтобы справится с перемещающим сборщиком мусора, все указатели на объекты Java кучи помещаются в специальный массив, о котором знает сборщик мусора. В результате, нативный код взаимодействует только с косвенными указателями. Из-за того, что нативный код не гарантирует расстановку ``безопасных точек''\footnote{Safe point --- место в программе, где она может остановиться для некоторого этапа сборки мусора или деоптимизации. В частности, это означает, что известно расположение объектов в регистрах и на стеке.} с какой-либо регулярностью, на время всего исполнения нативного кода поток погружаетя в безопасное состояние, а все функции, обладающие доступом к Java куче, замедляются из-за того, что должны возвращаться из этого безопасного состояния. Для ускорения программ существуют некоторые ``критические'' функции, такие как \texttt{GetPrimitiveArrayCritical}, которые дают настоящий указатель, но могут заблокировать все Java приложение до тех пор, пока этот указатель не будет освобожден.\\
Доступа из Java к нативной куче нет, что обязывает создавать нативные функции доступа, которые, в свою очередь, работают медленнее, чем ``аналогичные'' написанные на Java из-за невозможности встраивания и погружения в безопасное состояние. К другим ограничениям, для нативных функций необходимо генерировать специальные заголовочные файлы.\\
\subsubsection{Project panama}
Проект старается бороться с ограничениями JNI: добавляет доступ из Java к объектам на нативной куче (условно по указателям, но проще и безопаснее, чем \texttt{sun.misc.Unsafe}); добавляет поддержку нативных функций с переменным числом аргументов (в Java они бы запаковались в массив, в то время как в нативном соглашении о вызовах передались бы в небезопасной манере: через регистры или стек, без контроля за числом аргументов, что, конечно, менее безопасно, однако имеет свои применения).\\
Декларация структур с нативным расположением полей может помочь и обычным Java приложениям, т.к. виртуальная машина имеет право переупорядочивать поля, а задание строгого расположения может помочь избежать, например, false sharing'а\footnote{false sharing~---ситуация, когда два потока обращаются по разным адресам памяти, которые, однако, расположены на одной кэш-линии, что приводит к ухудшению производительности}, за счет добавления неиспользуемых полей.
\subsubsection{Haskell FFI}
Позволяет вызывать функции языка C с примитивами и указателями, что делает его крайне ограниченным и однонаправленным. Однако, есть возможность доступа к полям структур через смещение и размер, что, в сочетании с аппликативом, позволяет относительно удобно реализовывать сериализацию и десереализацию в структуры языка Haskell. Большинство реализаций FFI имеют схожий ограниченный функционал.
\subsubsection{LuaJIT FFI}\label{intro:luajitffi}
Добавляет полноценный синтаксический анализатор деклараций языка C~\cite{luajit}, благодаря чему расширяет типовую систему lua добавлением нового типа \texttt{cdata} в добавок к таблицам, числам и т.д. Данный подход позволяет вызывать нативные функции и обращаться к полям нативных структур с той же производительностью, что и изначальный язык --- C (за исключением проверок типов) благодаря эффективной JIT компиляции и простоте языка.
\subsubsection{CPPYY}
Позволяет вызывать различные конструкции языка C++ из Python при помощи использования проекта cling: интерпретатора и JIT компилятора C++, построенного на основе LLVM. В то время, как он является удобной заменой автоматическим генератором ``клея'' (файлов, описывающих доступные функции), и может быть использован для выноса крупных частей приложения на C++ для ускорения, он не устраняет стоимость вызова процедур в питоне, и может ее даже увеличивать за счет необходимости преобразований типов и связанных с этим аллокаций (например, \texttt{int} в питоне это большое число, но в рамках перехода между языками оно может быть преобразовано к \texttt{int} из C, что, на ряду с проверкой типов, будет требовать запаковку или распаковку). Замер скорости на маленькой программе в приложении~\ref{apx:cppyy-bench} демонстрирует этот эффект.

\subsection{Управляемый-управляемый}
Данная работа принадлежит именно этому разделу, и он является наиболее интересным для реализации, поскольку межъязыковое взаимодействие значительно упрощается, если обе реализации языков находятся под управлением одной виртуальной машины, поскольку это позволяет избежать многих проблем, таких как наличие двух сборщиков мусора.
\subsubsection{JVM/.NET}
Многие языки (такие как Kotlin) имеют относительно близкую к ``главному'' языку (Java или C\#) систему типов, что позволяет компилировать их в байткод виртуальной машины без значительной потери производительности. Другие же языки должны вносить компромиссы в свой дизайн, как, например, \texttt{null} значения в языке F\#, чтобы быть полностью совместимыми с другими языками и позволить постепенную миграцию на допускающий меньшее число ошибок во время исполнения язык.
\subsubsection{Nashorn}
Nashorn это реализация стандарта ecmascript на JVM, которая использует исключения для создания деоптимизаций и инструкцию \texttt{invokedynamic} для поддержки динамической типизации. В то время, как на простых мономорфных тестах данный проект может догнать или обогнать v8, на более сложных полиморфных примерах начинают становиться видны недостатки ``позитивных типов'' и нехватка специализированного динамического профиля.

\subsubsection{GraalVM}
Новейшая виртуальная машина, полагающаяся на мета-трассирующие оптимизации\footnote{Meta tracing~--- подход, при котором создается интерпретатор дерева (потенциально, со специальными командами, о которых знает JIT компилятор), который затем компилируется в предположении, что код не изменен}. Несмотря на удивительные результаты с точки зрения простоты разработки нового языка, реализация которого будет обладать высокой пиковой производительностью, данный подход, к сожалению, имеет некоторые недостатки. В частности, реальным проектам важны и другие характеристики, такие как объем потребляемой памяти, время загрузки, скорость интерпретации и энергопотребление на компиляцию. Наличие целого абстрактного дерева и его интерпретация может быть не позволительна, например, в браузерах на мобильных платформах. Это подробно обсуждается в презентации по добавлению интерпретатора ignition в v8~\cite{ignition-iterpreter}.

\section{Недостатки существующих решений}
Когда один из языков не находится под управлением виртуальной машины либо они находятся под управлением разных, возникает множество сложностей связанных, например, со сборкой мусора, которая при перемещающем сборщике мусора ведет к накладным расходам на каждое обращение.\\
Если же рассматривать решения, использующие одну виртуальную машину, то зачастую эта вирутальная машина заточена под один конкретный язык, что крайне ограничивает языко-специфичные подходы, такие как NaN упаковка, используемая в LuaJIT или пометка указателей, используемая в v8\cite{v8-pointer-tagging}, поскольку они требуют низкоуровневой поддержки со стороны различных компонент виртуальной машины. По этой же причине расширение стека для корутин так же не представляется возможным, поскольку реализуется через расширенный пролог метода и модификацию сборщика мусора для миграции стеков, хотя используется в эталонных реализациях таких языков как Elixir и Golang \cite{golang-stack}.

\finishrelatedwork

\section{Что отличает платформу Ark?}
Платформа Ark объединяет в себе несколько виртуальных машин, реализации которых различны и могут иметь разные, никак не связанные, среды исполнения, наборы инструкций и представления объектов, делающие их несовместимыми, однако эти реализации имеют общие компоненты, что оставляет возможность для добавления межъязыкового взаимодействия. Например, управление памятью и сборщик мусора почти полностью унифицированы. Такой подход позволяет реализовать каждую виртуальную машину в наиболее эффективной манере: с сохранением таких подходов как NaN запаковка; но не позволяет получить такое же простое взаимодействие языков на уровне байткода и устоявшейся системы типов как, например, JVM.\\
До начала данной работы межъязыковое взаимодействие на платформе полностью отсутствовало.

\section{Наивное решение}
Было бы возможно завернуть каждый объект статически типизированного языка в некоторый \texttt{Proxy}, который бы вызывал нативный код среды выполнения, а она бы в свою очередь за счет библиотеки рефлексии вызывала нужный метод или считывала поле. Однако, такое решение не только совершенно не эффективно (поскольку переключение контекста на нативный и использование рефлексии это достаточно дорогие операция в сравнении с простым чтением поля объекта), но и ломало бы, например, рефлексивность равенства: чтение поля ссылочного типа каждый раз возвращало бы новый \texttt{Proxy} объект.\\
Данный подход не использовал бы то, что оба языка находятся в управляемой среде.

\section{Обзор предлагаемого решения}
Добавление межъязыкового взаимодействия на платформу Ark может быть решено за счет разделения задачи на две практически независимые части:\\
\begin{enumerate}
	\item ``низкоуровневые'' изменения платформы, такие как, например, обход стеков;
	\item набор протоколов по которым виртуальные машины ``договариваются'' о том, как происходит взаимодействие (что включает в себя, например, конверсии типов).
\end{enumerate}
Об этих двух составляющих и пойдет речь в главах \ref{ch:platform} и \ref{ch:architecture} соответственно.\\
Т.к. данная работа фокусируется на изменениях среды исполнения, а большая часть статически типизированных языков полагается на ``компиляторную магию'' или ``синтаксический сахар'', эта часть будет освещена довольно поверхностно, покрывая только необходимые ``примитивы'', но не их синтаксическое представление в исходном коде. Полученные конструкции будут во многом аналогичны динамически типизированной стороне, однака большая часть реализации должна находиться в компиляторе, что выходит за рамки данной работы.

\chapterconclusion

\chapter{Изменение компонент платформы и детали их реализации}\label{ch:platform}
Как показано в фигуре \ref{fig:all-components}, затрагиваются практически все компоненты платформы, за исключением AOT компилятора, в котором нет информации профиля, необходимого для оптимизации межъязыкового взаимодействия.
\begin{figure}[!h]
	\caption{Компоненты платформы, участвующее в выполнении кода}\label{fig:all-components}
	\centering
	\includesvg[width=0.6\textwidth]{build/res/dot/components.dot}
\end{figure}

\section{Представление объектов на статически типизированной стороне}
Дерево типов должно быть немного модифицировано, путем добавления нового корня, и переподвешиванием к нему старого, как показано в фигуре~\ref{fig:statically-typed-tree}.

\begin{figure}[!h]
	\caption{Модификация иерархии статически типизированного языка}\label{fig:statically-typed-tree}
	\centering
	\includesvg{build/res/dot/statically-typed-tree.dot}
\end{figure}
Проверки типов и их преобразования также должны отличаться от обычных, что связано с особенностями реализации: в обеих реализациях тип представляющий класс объекта наследует некоторый \texttt{BaseClass}, содержащий, например, информацию для сборщика мусора. Однако, это не позволяет ни использовать библиотеку рефлексии, ни преобразовывать их друг к другу, поскольку последующее представление в памяти уже различно. Необходимо добавить команду компилятора, читающую указатель на \texttt{BaseClass} и берущую флаги из нее, где указано динамический ли класс у объекта. Т.к. \texttt{Object} и \texttt{DynamicObject} никак не связаны, компилятору следует требовать преобразование через \texttt{SomeObject}, как это реализовано, например, в F\#. Преобразование к \texttt{SomeObject} может быть соблюдено без каких либо проверок, поскольку этот класс является лишь синтетической абстракцией, без какого-либо представления во время выполнения.\\
\texttt{DynamicObject} может иметь некоторые расширения, такие как доступ к свойствам через точку или квадратные скобки, который будет компилироваться в нечто особенное, или иметь большее число наследников для выражение лучшей типовой безопасности.

\section{Представление объектов на динамически типизированной стороне}\label{nan-boxing-explanation}
%Их прочих решений, LuaJIT является ближайшим с динамически типизированной стороны: предлагается добавить новый тег в NaN упаковку, представляющий дерево типов ``инородных'' объектов (``foreign objects'' на некоторых схемах). Затем, эти типы интегрируются в интерпретатор и в во встраиваемые кэши, которые так же используются как профиль при динамической компиляции, что позволяет внедрить новые оптимизации.\\
В динамически типизированных языках любое значение может быть представлено как указатель на некоторый \texttt{ObjectHeader}, однако, такой подход потребляет значительное количество памяти из-за необходимости постоянных аллокаций и индирекций, что может еще и привести к удлинению пауз сборщика мусора. Из-за этого многие реализации используют одну из двух стратегий: пометка указателей (pointer tagging) или NaN упаковка (NaN boxing). Платформа Ark использует второе. Эта техника опирается на то, согласно стандарту IEEE-754 число с плавающей точкой двойной точности представляется как экспонента из всех единиц, и единичный бит мантиссы тоже выставляется в единицу, чтобы сделать его не сигнализирующим. В предположении, что все NaN значения, которые может сгенерировать процессор имеют нулевую мантиссу (кроме бита на сигнализирующий ли, ``qNaN Indefinite'' на x86 процессоре), остаются не занятыми 50 бит, в которые можно поместить некоторый ``тег'' и ``значение''. Эти значения визуализированы в фигуре~\ref{fig:nan-explain}, однако платформа Ark использует некоторую модификацию, что является деталью реализации и не умаляет общности. При помощи сжатия указателя или специального аллокатора можно добиться того, чтобы любой указатель на управляемый объект помещался в это количество бит.\\
\begin{figure}[!h]
	\caption{Число с плавающей точкой и NaN упаковка.}\label{fig:nan-explain}
	\centering
	\begin{tabular}{|c|c|c|c|c|c|}
		\hline
		число бит & 1 & 11 & \multicolumn{3}{c|}{52} \\
		\hline
		значение & знак & экспонента & \multicolumn{3}{c|}{мантисса} \\
		\hline
		NaN & знак & 1\dots 1 & \multicolumn{3}{c|}{мантисса} \\
		\hline
		qNaN indefinite & знак & 1\dots 1 & 1 & \multicolumn{2}{c|}{0\dots0} \\
		\hline
		кодирование & знак & 1\dots 1 & 1 & тэг & значение \\
		\hline
	\end{tabular}
\end{figure}
Таким образом, для представления инородных объектов можно ввести новый тег, по которому будет храниться ссылка на статически типизированный объект. Для представления же статических сущностей, можно сделать небольшую ``перегрузку'' этой семантики: ввести специальное поведение для случая, когда хранимая ссылка указывает на \texttt{Class} (объект, представляющий тип).\\
Данное изменение схоже с подходом, используемом в проекте LuaJIT FFI и описанном в обзоре~\ref{intro:luajitffi}.

\section{Встраиваемые кэши}
Для ускорения выполнения некоторых инструкций, они имеют встраиваемые кэши, данные из которых затем используются оптимизирующим компилятором как профиль. Например, инструкция байткода \texttt{LdObjByName}, которая загружает свойство объекта по константному имени, сохраняет в себе динамический класс и число, представляющее смещение на искомое поле в нем. Таким образом, сначала кэш пустой, и во время исполнения необходимо узнать данные о классе: он представляется массивом или хэш-таблицей, затем при помощи подходящего алгоритма найти искомое значение ключа, обновить встраиваемый кэш и загрузить запрашиваемое значение. При повторном выполнении будет достаточно сравнить класс и сразу же загрузить значение в случае его совпадения, без совершения всех длительных действий и обращений к структурам данных, которые совершает медленный путь исполнения.\\
Встраиваемые кэши должны быть расширены для поддержки инородных объектов за счет добавления еще одного медленного пути: проверки, что объект инородный, затем обращения к другой виртуальной машине с целью получения обработчика, либо вызов всех накопленных в кэшах обработчиков до тех пор, пока какой-то из них не подойдет. Такой подход требует виртуального вызова на каждую обработку, однако позволяет унифицировать разные языки за одним интерфейсом. Код интерпретатора для, например, загрузки поля из статически типизированного объекта не может быть сокращен настолько же значительно, насколько и у динамически типизированного, поскольку необходима конвертация значения, зависящего от поля, в NaN упакованное, что в любом случае обязано привести к виртуальному вызову или условной проверке какую конверсию выбрать, что будет ``медленным'' путем.\\
Можно заметить, что и функции и типы, изначально хранимые во встраиваемых кэшах изначально были неподвижными (для сборщика мусора) и с бесконечным временем жизни, т.к. это необходимо для работы асинхронного JIT компилятора. Из-за чего и новые данные, хранимые там так же должны удовлетворять этим свойствам, что добавляет новый класс корневых объектов ко всей виртуальной машине.

\section{Работа с полями объектов}
В то время, как на первый взгляд может показаться, что для загрузки достаточно просто вставлять проверку на инородный тег, расширение известного класса, а затем запаковывать полученное значение в соответствующее примитивное (\texttt{int32}, \texttt{float64}, \texttt{bool}) или очередной объект (что, тем не менее, контролируется типовыми системами языков, описанными в главе~\ref{ch:architecture}), несколько новых оптимизаций необходимы. Основная из них продемонстрирована в фигуре~\ref{fig:field-opt}: удаление распаковки после запаковки с несколькими нюансами. Во-первых, запакованное значение должно остаться в ``сохраненном состоянии''\footnote{Save state~--- состояние, где известно какие регистры и какие адреса на стеке соответствуют какому состоянию интерпретатора: регистрам, стеку и номеру инструкции интерпретатора. Это состояние может потребоваться в случае, если произойдет сборка мусора}, потому что занимает некоторый виртуальный регистр $v_i$, который может быть использован в случае дальнейшей деоптимизации. Однако, эта лишняя ``запаковка'' вероятно будет удалена при последующих оптимизациях, если они сочтут это безопасное состояние не используемым. Во-вторых, т.к. инородный объект это ссылочный тип, его в не завернутом состоянии тоже необходимо положить в последующее безопасное состояние, чтобы в случае сборки мусора ссылка на него обновилась. Т.к. ему не соответствует ни один виртуальный регистр, он помещается в так называемый мост (bridge). И, наконец, последующие проверки на принадлежность к классу (\texttt{IsInstance}) могут быть статически изменены на проверки на \texttt{null}, поскольку JIT компилятор изначально полагается на компилятор статически типизированного языка, и в аналогичном коде двойного доступа к полю вставляет только проверки на нулевой указатель, но не на тип операнда. Эта проверка на нулевой указатель может быть и дальше удалена за счет информации о типах из статически типизированного языка, если он ее предоставляет, или заменена на обработку сигнала операционной системы.\\
Сохранение полей не является примечательным с точки зрения модификаций платформы.

\begin{figure}[H]
	\caption{Оптимизация запаковки и распаковки инородных объектов.}\label{fig:field-opt}
	\centering
		\resizebox{\textwidth}{!}{
			\begin{tabular}{ |c|c| }
				\hline
				До & После \\
				\hline
				\includesvg{build/res/dot/load-field-1.dot} & \includesvg{build/res/dot/load-field-2.dot} \\
				\hline
			\end{tabular}
		}
	\end{figure}

\section{Управление потоками} \label{sec:thread-management}
Для исполнения управляемого кода необходимы дополнительные данные (в пример можно привести буферы аллокации локальные для потока), которые инкапсулируются в то, что в данной работе будет называться ``состоянием потока''. Это состояние во время интерпретации хранится в переменной локальной для потока, а в управляемом коде передается через регистр. Важно заметить, что при пересечении языковой границы необходимо сохранить его консистентность, что добавляет новое действие в некоторые места, такие как мост перехода из скомпилированного кода в интерпретатор, поскольку без использования межъязыкового взаимодействия значение состояния потока является константным после первого присвоения. Такой переход возможен, если каждый поток будет осведомлен о положении переменной локальной для потока, которой он принадлежит. При такой реализации не может возникнуть гонок данных, т.к. все действия происходят внутри одного реального потока.\\

Большинство динамически типизированных языков либо не позволяют создавать потоки (Lua, ecmascript), либо имеют глобальный лок интерпретатора (CPython, Ruby MRI). Есть несколько языков с поддержкой многопоточности, но они либо фокусируются на производительности (Julia), либо построены вокруг распределенности (Erlang, Elixir, в которых даже сборщик мусора работает внутри одного потока~\ref{erlang-gc}). Из этого было бы возможно вывести ограничение, что динамически типизированный язык должен взаимодействовать только с привязанным к этому же нативному потоку состоянием потока статически типизированного языка. На самом деле, такое ограничение является довольно распространенным и присутствует так же в библиотеках на подобие OpenGL.\\
Управление потоками важно для сборки мусора, поскольку существуют фазы ``остановки мира''\footnote{англ. stop-the-world}, в которые все потоки, выполняющие управляемый код, должны остановиться. Это может быть реализовано за счет, например, блокировки чтения-записи (readers-writer lock): исполняемые потоки берут право на чтение, а желающий их остановить на запись, и тогда его попадание в критическую секцию будет означать, что все потоки остановлены. Из-за того, что необходимо выполнять два состояния потока разных языков на одном реальном, принадлежащем операционной системе, может возникнуть путаница или неправильное количество держателей лока на чтение, и ``правильной'' архитектурой было бы иметь отдельно потоки выполнения которые бы исполняли корутины.

\section{Вызов методов}
Как сказано в секции \ref{sec:thread-management}, у каждого языка есть свое ``состояние потока''. Т.к. в скомпилированном коде указатель на это состояние лежит в регистре, и передается из функции в функцию по соглашению о вызовах, изменение могло бы быть закодировано как обычный \texttt{mov} известной константы до и после вызова, однако при обработке исключений и разворачивании стека данное состояние необходимо вернуть, чего можно добиться за счет создания дополнительного промежуточного стекового кадра. Его расположение внутри кадра метода, вызывающего инородную функцию, представлено в фигуре~\ref{fig:method-stack} и обозначено как ``Дополнительный кадр''. Данный кадр может быть заполнен единожды в прологе метода, с последующим обновлением адреса возврата перед каждым вызовом. Для восстановления своего состояния потока после нормального возврата вызова инородного метода может быть использован этот же кадр.
\begin{figure}[!h]
\caption{Новое расположение данных в стековом кадре метода}\label{fig:method-stack}
\centering
\begin{tabular}{|c|@{}cr@{}|}
	\hline
	\multicolumn{2}{|c}{Адрес возврата}&\tikz\node[na](frameUpper){};\\
	\hline
	\multicolumn{2}{|c}{Указатель на предыдущий кадр}&\\
	\hline
	\multicolumn{2}{|c}{Локальные переменные}&\\
	\hline
	Дополнительный кадр&\multicolumn{2}{@{}c@{}|}{\begin{tabular}{c}
	Адрес возврата\\
	\hline
	Указатель на предыдущий кадр\tikz\node[na](frameLink){};\\
	\hline
	Специальное число\\
	\hline
	Указатель на состояние потока\\
	\end{tabular}}\\
	\hline
	\multicolumn{2}{|c}{Стековые аргументы}&\\
	\hline
\end{tabular}

\begin{tikzpicture}[remember picture,overlay,cyan,rounded corners,>=stealth,shorten > =1pt,shorten <=1pt,thick]
	\draw[->, color=black] (frameLink.east) to [bend right=45] (frameUpper.east);
\end{tikzpicture}

\end{figure}

\section{Управление памятью}

\section{Сборка мусора}
\subsection{``Маркеры''}
Сборка мусора на платформе Ark по большей степени обобщена, однако самые низкоуровневые примитивы, которые, например, размечают и обходят объекты обязаны быть разными. Они параметризованы конфигурацией языка, которая, помимо прочего, указывает динамический ли язык. Для максимального переиспользования кода, данная структура может быть применено нетривиальное (и потенциально виртуальное) наследование, как показано в фигуре~\ref{fig:gc-markers} (жирным выделены переименованные фрагменты).\\
Изначально, код, размечающий объекты, имел \texttt{assert}, что класс полученного объекта соответствует контексту, и эта проверка удалялась в итоговой сборке платформы, поскольку включала атомарное чтение и условие в коде, который может выполняться десятки тысяч раз. Таким образом, чтобы не ``переплачивать'', если конфигурация (уже не языка, а платформы) указывает, что разрешено межъязыковое взаимодействие, то вставлять проверку и переключать маркер на статический режим, а иначе вызывать \texttt{assert}, который будет удален. Можно выдвинуть гипотезу, что переключение контекста происходит крайне редко, и подсказать это компилятору через встроенные команды.\\
Таким образом, \texttt{Marker} может быть переименован в \texttt{MarkerImpl} с минимальными изменениями и без ухудшений производительности в случае, когда с данным сборщиком мусора может исполняться только один язык.
\begin{figure}[H]
\caption{Модификация иерархии маркеров}\label{fig:gc-markers}
\centering
	\resizebox{\textwidth}{!}{
		\begin{tabular}{ |c|c| }
			\hline
			Старая & Новая \\
			\hline
			\includesvg{build/res/dot/marker_was.dot} & \includesvg{build/res/dot/marker_new.dot} \\
			\hline
		\end{tabular}
	}
\end{figure}
\subsection{Обход стеков}
Т.к. представление объектов на стеке зависит только от метода, для которого известно динамический ли он, и который хранится в каждом стековом кадре, модификации алгоритма сканирования не требуются. Однако, т.к. два состояния потока находятся на одном реальном стеке, необходимо проверить кто из них сейчас активен (и является самым верхним). Это можно сделать за счет той переменной, добавленной для поддержки консистентности регистра потока и переменной: если значение переменной совпадает с исследуемым потоком, то он активен. Поскольку стек обходиться только во время фаз ``остановки мира'' (таких как ``initial mark pause'' и ``remark pause''), гонки данных не появляется.
\subsection{Перемещение объектов}
На перемещение объектов влияет факт добавления нового объектного тега в NaN упаковку на динамически типизированной стороне. Из-за этого перемещающий код не может копировать значения 1 в 1, как это было раньше, а должен сохранять их тег из предыдущего значения. Данное изменение влечет лишь пару битовых операций.


\section{Проблемы межъязыкового взаимодействия}
\subsection{Строки}
Т.к. представление строк в памяти различно, необходимо копирование. Благодаря неизменяемости в большинстве языков, можно было бы добавить указатель из динамически типизированной строки к обычной, который затем лениво инициализировать. Обратная трансформация не может быть осуществлена из-за многопоточности и того, что статический язык может быть связан с несколькими динамическими. Однако, благодаря тому, что это инородный объект, многие методы будут все так же доступны.

\subsection{Массивы}
% https://wiki.python.org/jython/CollectionsIntegration
Массивы сталкиваются с проблемами аналогичными строкам: у них разные типы. Однако, динамическому языку это может быть не заметно благодаря ``утиной'' типизации, если языко-специфичный интерфейс предоставлен на ряду с обычным. С другой стороны, возникают проблемы с вариантностью для типизированного массива, поскольку эта информация может теряться на уровне байткода.\\
Другие реализации, такие как jython, запрещают конверсии массивов. В предложенной реализации на платформе Ark статически типизированные массивы на динамически типизированной стороне обладают только доступом по индексу и свойством длины.

%\subsection{Возвращение экземпляров примитивных типов из динамически типизированных функций.}
%Так как тип \texttt{any} не может быть представлен на статически типизированной стороне из-за несоответствия представления объектов, одна из следующих стратегий может быть использована:
%\begin{itemize}
%	\item всегда возвращать некоторый \texttt{TaggedValue}, который имел бы два поля: \texttt{uint64} для сохранения изначального значения \texttt{any} (и который может стать некорректным в случае перемещения объекта, однако информация о типе останется верной) и поля типа \texttt{SomeObject}, в котором хранилась бы ссылка на объект или \texttt{null} в случае примитивного значения. Затем, предоставление всего набора функций для проверки принадлежности и преобразований, покрыло бы все возможные использования. При этом подходе, можно было бы избежать аллокации при помощи передачи \texttt{TaggedValue} как аргумента для заполнения, вместо возвращаемого значения.
%	\item В случае примитивных типов возвращать их запакованные версии. При данном подходе аллокация в общем случае неизбежна, однако проверка типа будет сводиться проверке на \texttt{null}, загрузке указателя на класс и сравнению, т.к. примитивные типы нельзя расширять. Оптимизирующий компилятор в случае нескольких проверок подряд может выделить общий код, чем практически приравняет сложность проверки к ложности в предыдущем случае.
%\end{itemize}
%Т.к. второй подход более идиоматичный, выбирается именно он. Благодаря этому месту можно заметить недостаток разного представления объектов, которого нет, например, в Graal VM.\\
%Однако, в будущем планируется добавить возможность представления типа \texttt{any} в регистрах на динамически типизированной стороне с дополнительными операциями проверки принадлежности к нескольким базовым типам, представимым уже в типовой системе статически типизированного языка.
\subsection{Наследование}
Наследование возможно реализовать за счет генерации статического класса, наследующего данный с дополнительным полем: динамическим объектом (\texttt{DynamicObject}), который бы переопределял все методы следующим образом: сначала проверить есть ли поле с соответствующем именем внутри того объекта, и если нет, то вызвать родительский (или вызвать исключение о неопределенном абстрактном методе). Данный механизм в прототипе не был реализован, поскольку наилучшим образом реализуется через аналог \texttt{DynamicProxy} из языка Java, отсусттвующего на платформе в данный момент.
\subsection{Null}
Внимательный читатель мог заметить, что расширение системы типов новым тегом на динамически типизированной стороне не прошло незамеченным: появился еще один \texttt{null}, что указывает на некоторые недостатки использования NaN упаковки вместо способа, который использует Graal VM: простой запаковки примитивов в их объектные аналоги.\\
Помимо этого, существует несколько способов ``борьбы'' с ``пустыми'' значениями из динамического языка (например, во что должен превращаться \texttt{undefined}): они все могут преобразовываться к \texttt{null}, либо быть представлены аналогично \texttt{Unit} из языка Kotlin: константными ссылочными значением. Первый способ не уступает второму, поскольку \texttt{undefined} чаще всего означает отсутствие возвращаемого значения, а, например, в Java, запакованный тип \texttt{Void} представляется единственным значением~--- \texttt{null}.

\chapterconclusion
\TODO
Можно заметить, что порой ставится вопрос о выборе между производительностью и удобством использования, и что в области межъязыкового взаимодействия есть некоторые нерешенные задачи, такие как совместимость строковых типов.

\chapter{Общая архитектура}\label{ch:architecture}
Для того, чтобы низкоуровневые изменения заработали, необходимо добавить работу с ними в процесс исполнения. Общая схема могла бы быть представлена, как ``интерпретатор $\rightarrow$ встраиваемые кэши $\rightarrow$ скомпилированный код'', т.к. встраиваемые кэши так же представляют профиль исполнения.\\
Каждая виртуальная машина снабжается интерфейсом межъязыкового взаимодействия, через который можно в частности получить дополнительные узлы исполнения общих действий, таких как чтение значения по имени. Эти узлы могут быть как аллоцированы для использования во встраиваемых кэшах, так и созданы локально на стеке. Разделение на такие подходы позволяет избежать аллокаций памяти и сбора дополнительного профиля в ситуациях, когда данный интерфейс будет сразу же уничтожен.\\
Каждый узел должен обладать следующим набором методов:
\begin{itemize}
	\item создание, принимающее интерфейс создающего языка;
	\item интерпретация соответствующих методов;
	\item компиляция интерпретируемых методов.
\end{itemize}
На схеме взаимодействия в фигуре~\ref{fig:create-interop-node} продемонстрирована примерная схема работы: виртуальная машина~1 (VM1) при обнаружении инородного объекта обращается ко второй виртуальной машине с целью получения конкретного узла (на схеме обозначено зеленой стрелкой). За счет того, что в момент создания узлу доступны обе виртуальные машины, появляется общая система типов, и осуществляется взаимодействие в обе стороны: чтение отсутствующего аттрибута может быть перенаправлено назад в язык, за счет чего обеспечится семантика вызывающего языка: поднимется исключение или будет возвращено специально значение, например, \texttt{undefined}. Затем для исполнения виртуальная машина обращается к этому узлу, который может быть сохранен во встраиваемых кэшах или ``вызываемой стороне'' полиморфного вызова.
\begin{figure}[!h]
	\caption{Схема работы узла межъязыкового взаимодействия}\label{fig:create-interop-node}
	\centering
	\includesvg{build/res/dot/architecture-sample.dot}
\end{figure}

Можно заметить, что при данном подходе необходимо реализовать только необходимые действия, такие как нахождение сущностей (полей и методов) по имени и конверсии типовой системы, проходящие через некоторый установленный набор типов.

\section{Конверсии типов}
Важно сохранение семантики обоих языков, для чего взаимодействие происходит через набор некоторых примитивных типов и два вида объектных. Динамически типизированный язык в такой ситуации может реализовывать сильную или слабую динамическую типизацию, а статически типизированный язык сохранять правила конверсии. Например, конверсия из \texttt{float64} в \texttt{int8} может быть сделана несколькими способами: при помощи усечения, как в C++ (инструкция \texttt{cvttsd2si} на процессоре x86-64), или с семантикой аналогичной Java: сначала происходит преобразование к \texttt{int32} со специальными правилами (например, если значение числа с плавающей точкой больше максимального допустимого, то результат считается равным второму), и затем полученный \texttt{int32} конвертируется к числу меньшей битности~\ref{java8-spec}.\\

\section{Вызов методов на статически типизированной стороне}
Для вызова методов со статически типизированной стороны идеально подошла бы инструкция \texttt{invokedynamic}, которая бы позволяла передать сигнатуру, содержащую типы аргументов, известные в точке вызова, и передавала управление узлу межъязыкового взаимодействия. Однако, данная инструкция отсутствует в данный момент на платформе, из-за чего кастомизация за счет узлов невозможна и осуществляется при помощи конечного числа перегрузок.\\
Для определения языка, отвечающего за конверсии или конкретной виртуальной машины, если несколько машин для одного языка могу сосуществовать в одном реальном потоке. Этого можно достигнуть несколькими способами: либо заворачивать все объекты в дополнительную прослойку, которая будет знать о привязанной виртуальной машине; либо совершать все взаимодействие через переменную, предоставляющую к ней доступ. Второй способ является более производительным, чем первый, поскольку не требует дополнительных выделений памяти, но усложняет добавление синтаксического сахара для работы с динамическими объектами, возможно добавление некоторого аналога \texttt{with} из языка программирования Kotlin.
% что является практически обязательным, при условии что они все привязаны к своему потоку, и могут быть нужны в целях безопасности, как, например фреймворк Electron разделяет контекст в котором происходит отрисовка, от контекста с логикой, то необходимо везде передавать указатель на виртуальную машину (в терминологии v8~---isolate)
%В любом из описанных случаев, если указатель сохраняется в переменную с единственным присваиванием, то он потенциально может быть оптимизирован JIT компилятором. Для реализации такого вызова может использоваться некоторый аналог \texttt{invokedynamic}, содержащий в себе сигнатуру метода с типами аргументов, соответствующими статически известным.

\subsection{Вызов методов на динамически типизированной стороне}
Наибольшую сложность для вызова методов на динамически типизированной стороне представляет перегрузка функций и методов. Это видно и по тому, разрешают ли ее наиболее популярные языки:
\begin{itemize}
	\item не разрешают: lua, python, ruby, ecmascript;
	\item разрешают по числу аргументов: elixir, erlang (и Prolog);
	\item разрешают несколько сигнатур: typescript
\end{itemize}
Перегрузка по числу аргументов зачастую разрешается в точке вызова на этапе компиляции или преобразования в байткод за счет изменения имени, в остальных случаях языки обязывают иметь одно общее тело функции и выбирать путь через динамические конструкции такие как \texttt{typeof}. Возможно собрать профиль типов аргументов в точке вызова, однако это замедлит выполнение в случае, когда межъязыковое взаимодействие не используется, без особых преимуществ, в то время как хотелось бы следовать принципу ``not pay for what you don't use''\footnote{англ. не плати за то, что не используешь}. Таким образом, наиболее выгодная стратегия это найти наиболее общую перегрузку, или, если ее не существует, вернуться к исходному уровню компиляции\footnote{англ. baseline~--- компиляция из байткода 1 в 1, без применения оптимизаций, зачастую сводится к вызову интринсика}, который переберет все подходящие.\\
Однако Graal VM вызывает самую специфическую версию, т.е. \texttt{f(1)} вызывает \texttt(f(int8)), а не \texttt{f(int32)}. На первый взгляд может показаться, что такой подход лучше, однако он имеет значительные недостатки:\\
\begin{enumerate}
	\item Численные литералы по-разному обрабатываются в языках программирования: если в какой-то степени поддерживается вывод типов (в случае чего язык почти наверняка не поддерживает уже перегрузку), литерал скорее всего представляется как \texttt{intSome}, например \texttt{fromInteger 1 :: Num} в языке программирования Haskell, или \texttt{comptime\_int} в Zig'е. Этот тип затем может быть преобразован к нужному во время решения системы уравнений о типах. В Java, $1$ представляет собой литерал типа \texttt{int}, а значит \texttt{f(1)} вызовет именно \texttt{f(int32)}, а не от более узкого типа, что означает, что при простом переносе строчки из статически типизированного языка в динамически типизированный изменилась семантика.
	\item Нахождение ``самой конкретной специализации'' означает добавление нескольких проверок во время исполнения, которых невозможно избежать за счет сбора профиля, поскольку даже если он говорит, что число поместиться в \texttt{int16}, это необходимо проверить, и в добавок к этому убедиться, что оно не помещается в \texttt{int8}. Если в языке присутствуют типы без знака, то картина усложняется еще сильнее, и становится совсем не понятно что выбирать, например, число $16$ должно вызвать функцию от целого числа без знака или со знаком? Если же на вход подается число с плавующей точкой, также необходимо проверить является ли оно целым.
	\item Такой вызов перегрузки в некотором смысле навязывает динамически типизированному языку чужую типизацию, ведь если в его системе есть только один численный тип~--- число с плавающей точкой двойной точности, то выглядит логичным вызвать перегрузку именно от него.
\end{enumerate}
При всем выше сказанном перегрузки по большей части ``прозрачны'': программисту не важно вызовется \texttt{print(int64)} или \texttt{print(int32)}, т.к. семантически они делают одно и то же.

\section{Аналогии}
Обобщая вышесказанное, можно заметить некоторую аналогию с мета-трассировкой, однако узлы межъязыкового взаимодействия локализованы именно для него, что позволяет сохранить преимущества платформы, при этом оставляя реализацию межъязыкового взаимодействия относительно простой и гибкой. В прототипе данные узлы и интерфейс реализованы на C++, поскольку их реализация невозможна на текущих управляемых языках платформы в частности потому, что требовала бы переключения состояния потока и не имела бы доступа к таким низкоуровневым операциям, как конвертация соглашений о вызовах.

\section{Особенности}
Данный подход обладает несколькими особенностями:
\begin{itemize}
	\item требуются аллокации узлов исполнения, из-за чего они расположены в адресах далеких от профиля, из-за чего доступ к памяти становится менее оптимальным с точки зрения промахов по кэшу. В результате чего они служат скорее для сбора профиля, чем для улучшения производительности;
	\item требуется индирекция при вызове; причем для обработки одного узла их может потребоваться несколько: например, при чтении статического поля его необходимо ``завернуть'' в динамическое значение, чем может заниматься специальный объект, предоставленный из динамического языка. Важно заметить, что количество статических типов ограничено, а значит все такие ``заворачиватели'' могут быть преаллоцированы и не обладать никакими условными проверками внутри, что позволит терять меньшее количество производительности.
\end{itemize}

У реализации на C++ есть ряд дополнительных недостатков, свойственных нативному коду:
\begin{itemize}
	\item ручное управление памятью, реализованное через подсчет ссылок;
	\item необходимость ввода ограничений на методы, которые могут вызывать сборщик мусора,
	\item необходимость аллокации некоторых данных как не перемещаемых.
\end{itemize}

\chapterconclusion
Не смотря на перечисленные особенности, данный подход позволяет унифицировать интерфейс межъязыкового взаимодействия с сохранением точек кастомизации, учитывающих семантики обоих языков.\\
Улучшение предлагаемого подхода заключается в наличии некоторого специального языка, который с одной стороны позволял бы совершать низкоуровневые операции, а с другой давал бы контролируемый доступ к управляемым конструкциям, таким как безопасные состояния. Наличие дополнительного языка позволяет упростить встраивание, поскольку избавляет от необходимости отдельно писать код, компилирующий узел и отдельно интерпретирующий. Схожая техника используется для упрощения разработки, например в v8 с языком torque \cite{torque}.\\
Таким образом, вместе с изменениями платформы данная архитектура позволяет скомпилированному коду на динамически типизированной стороне взаимодействовать с конструкциями статически типизированного языка без интринсиков или нативного кода после JIT компиляции, что удовлетворяет требованиям работы. Улучшения производительности со стороны статически типизированного языка находятся в разработке, поскольку на платформе не было никакого аналога \texttt{invokedynamic}, без использования которого ускорение взаимодействия не представлялось возможным ввиду динамической типизации.

\chapter{Результаты}
Как метрика объема проделанной работы могут выступать строки кода. Было добавлено более {\color{green}+7000}, а удалено менее {\color{red}-1000}.\\

Оценка корректности производилась за счет сравнения наблюдаемого поведения на наборе тестов с ожидаемым и верификацией, что интерпретируемый код дает тот же результат, что и скомпилированный, для чего JIT компиляция делалась синхронной.\\
Отслеживались события, такие как деоптимизация для проверки, что код инвалидируется при нарушении предположений и не происходит чтений неправильных адресов.\\
Для проверки работоспособности оптимизаций некоторые тесты проверяли число тех или иных инструкций после определенных проходов оптимизатора по промежуточному представлению JIT компилятора.

\section{Замеры производительности}
\subsection{Описание кода}
Замер производился на коде полученном путем модификации общепринятого теста ``Sunspider/AccessNBody'', входящего в набор разработанный командой WebKit. Данный тест не является полностью синтетическим, поскольку просчитывает положение тел в солнечной системе и выглядит примерно следующим образом:\\
\begin{center}
\begin{tabular}[t]{p{0.5\textwidth}|p{0.5\textwidth}}
\begin{lstlisting}
class System {
	class Body { x: double }
	advance(t: double): void
	bodies: Array<Body>
}
\end{lstlisting} &
\begin{lstlisting}
function System.advance(t) {
	// for i { for j {
	this.bodies[i].x +=
		this.bodies[j].x * t
	// } }
}
\end{lstlisting}
\end{tabular}
\end{center}

Т.е. в двойном цикле происходят действия над массивом ``структур''. Производительность сравнивается в трех модификациях, расположенных слева направо на каждой платформе и соединенных стрелками:
\begin{enumerate}
	\item сначала все объекты представлены динамически типизированными (dynamic);
	\item затем элементы массива~--- экземпляры типа \texttt{Body} заменяются на статически типизированные (static object);
	\item затем весь массив становится статически типизированным (static array).
\end{enumerate}
Так же важно заметить, что программа полностью мономорфна, т.е. при каждом вызове каждой функции типы аргументов (в том числе динамические классы) совпадают.\\
Результаты представлены в фигуре~\ref{fig:accessnbodyres}.
\begin{figure}[!h]
	\caption{Результаты замеров Sunspider/AccessNBody}\label{fig:accessnbodyres}
	\resizebox{\textwidth}{!}{\includesvg{build/res/data-build/access-nbody.svg}}
\end{figure}
Полные результаты, включающие информацию о процессоре, на котором выоплнялись замеры и исходный код модификаций доступны по ссылке: \url{https://github.com/kp2pml30/bachelor-thesis-info-mirror}

\subsection{Результаты на платформе Ark}
Результаты на платформе Ark оказались легко интерпретируемыми:
\begin{itemize}
\item при первом преобразовании стало на одну динамическую проверку меньше: чтение поля \texttt{Body.x} лишилось проверки на принадлежность числу, поскольку его тип заранее известен;
\item при втором же все проверки внутри цикла заменяются на простую проверку на нулевой указатель, поскольку известно, какому классу принадлежат элементы; за счет вида цикла проверки на выход за рамки массива так же отсутствуют.
\end{itemize}
Это и привело к последовательному улучшению производительности примерно в 2 раза.

\subsection{Результаты на других платформах}
Результаты на других платформах оказались куда менее очевидными, что, вероятно, связано с тем, что узлы интерпретатора (реализованные через \texttt{invokedynamic} в Nashorn) не адаптируются под объекты статически типизированного языка. Однако общая картина показывает, что платформа Ark в целом, и межъязыковое взаимодействие на ней в частности, являются конкурентно способными, и поигрывают node (v8) в то же число раз, что и альтернативные реализации.

\chapterconclusion
Полученный в результате выполнения работы прототип не только показал свою работоспособность в примитивных сценариях, но и позволил сократить время исполнения общепринятого теста за счет добавления статической типизации объекту, что является демонстрацией применимости межъязыкового взаимодействия.

\startconclusionpage
В ходе выполнения работы были получены следующие результаты:
\begin{enumerate}
	\item был проведен обзор области, покрывающий многочисленное число существующих решений для различных языков и платформ;
	\item было предложено решение для каждой компоненты виртуальной машины, участвующей в процессе, включая управление памятью, интерпретатор и компилятор;
	\item был предложен и реализован высокоуровневый интерфейс межъязыкового взаимодействия;
	\item код, демонстрирующий применимость предложенного подхода, был написан и опубликован;
	\item была проведена оценка результатов при помощи тестов и замеров производительности, которая показала хорошие результаты.
\end{enumerate}
Исходный код прототипа доступен по следующим ссылкам:
\begin{itemize}
	\item \url{https://gitee.com/kprokopenko/arkcompiler_runtime_core/tree/interop-mem/}
	\item \url{https://gitee.com/kprokopenko/arkcompiler_ets_runtime/tree/interop-mem/}
\end{itemize}

\printmainbibliography
\appendix

\chapter{Listings}
\begin{figure}[!h]
	\caption{Micro benchmark of function call in cppyy and python}\label{apx:cppyy-bench}
	%\centering
	\lstinputlisting[language=Python]{../data/cppyy-sample.py}
\end{figure}

\end{document}
